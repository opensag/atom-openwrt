diff -Naur a/drivers/net/usb/GobiUSBNet.c b/drivers/net/usb/GobiUSBNet.c
--- a/drivers/net/usb/GobiUSBNet.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/net/usb/GobiUSBNet.c	2020-01-15 10:15:11.561190516 +0800
@@ -0,0 +1,1477 @@
+/*===========================================================================
+FILE:
+   GobiUSBNet.c
+
+DESCRIPTION:
+   Qualcomm USB Network device for Gobi 3000
+   
+FUNCTIONS:
+   GobiNetSuspend
+   GobiNetResume
+   GobiNetDriverBind
+   GobiNetDriverUnbind
+   GobiUSBNetURBCallback
+   GobiUSBNetTXTimeout
+   GobiUSBNetAutoPMThread
+   GobiUSBNetStartXmit
+   GobiUSBNetOpen
+   GobiUSBNetStop
+   GobiUSBNetProbe
+   GobiUSBNetModInit
+   GobiUSBNetModExit
+
+Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of Code Aurora Forum nor
+      the names of its contributors may be used to endorse or promote
+      products derived from this software without specific prior written
+      permission.
+
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+===========================================================================*/
+
+//---------------------------------------------------------------------------
+// Include Files
+//---------------------------------------------------------------------------
+
+#include "Structs.h"
+#include "QMIDevice.h"
+#include "QMI.h"
+#include <linux/etherdevice.h>
+#include <linux/ethtool.h>
+#include <linux/module.h>
+
+//-----------------------------------------------------------------------------
+// Definitions
+//-----------------------------------------------------------------------------
+
+// Version Information
+#define DRIVER_VERSION "Fibocom_Linux_GobiNet_0930-demo"
+#define DRIVER_AUTHOR "Qualcomm Innovation Center"
+#define DRIVER_DESC "GobiNet"
+
+#define NODECOM_VENDOR_ID			0x1508
+#define FIBOCOM_VENDOR_ID			0x2CB7
+#define QUALCOMM_VENDOR_ID                      0x05C6
+
+// Debug flag
+int Gobi_debug = 1;
+
+// Allow user interrupts
+int interruptible = 1;
+
+// Number of IP packets which may be queued up for transmit
+int txQueueLength = 100;
+
+// Class should be created during module init, so needs to be global
+static struct class * gpClass;
+
+#ifdef CONFIG_PM
+/*===========================================================================
+METHOD:
+   GobiNetSuspend (Public Method)
+
+DESCRIPTION:
+   Stops QMI traffic while device is suspended
+
+PARAMETERS
+   pIntf          [ I ] - Pointer to interface
+   powerEvent     [ I ] - Power management event
+
+RETURN VALUE:
+   int - 0 for success
+         negative errno for failure
+===========================================================================*/
+int GobiNetSuspend(
+   struct usb_interface *     pIntf,
+   pm_message_t               powerEvent )
+{
+   struct usbnet * pDev;
+   sGobiUSBNet * pGobiDev;
+   
+   if (pIntf == 0)
+   {
+      return -ENOMEM;
+   }
+   
+#if (LINUX_VERSION_CODE > KERNEL_VERSION( 2,6,23 ))
+   pDev = usb_get_intfdata( pIntf );
+#else
+   pDev = (struct usbnet *)pIntf->dev.platform_data;
+#endif
+
+   if (pDev == NULL || pDev->net == NULL)
+   {
+      DBG( "failed to get netdevice\n" );
+      return -ENXIO;
+   }
+   
+   pGobiDev = (sGobiUSBNet *)pDev->data[0];
+   if (pGobiDev == NULL)
+   {
+      DBG( "failed to get QMIDevice\n" );
+      return -ENXIO;
+   }
+
+   // Is this autosuspend or system suspend?
+   //    do we allow remote wakeup?
+#if (LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,33 ))
+#if (LINUX_VERSION_CODE > KERNEL_VERSION( 2,6,14 ))
+   if (pDev->udev->auto_pm == 0)
+#else
+   if (1)
+#endif
+#else
+   if ((powerEvent.event & PM_EVENT_AUTO) == 0)
+#endif
+   {
+      DBG( "device suspended to power level %d\n", 
+           powerEvent.event );
+      GobiSetDownReason( pGobiDev, DRIVER_SUSPENDED );
+   }
+   else
+   {
+      DBG( "device autosuspend\n" );
+   }
+     
+   if (powerEvent.event & PM_EVENT_SUSPEND)
+   {
+      // Stop QMI read callbacks
+      KillRead( pGobiDev );
+#if (LINUX_VERSION_CODE > KERNEL_VERSION( 2,6,22 ))
+      pDev->udev->reset_resume = 0;
+#endif
+      
+      // Store power state to avoid duplicate resumes
+      pIntf->dev.power.power_state.event = powerEvent.event;
+   }
+   else
+   {
+      // Other power modes cause QMI connection to be lost
+#if (LINUX_VERSION_CODE > KERNEL_VERSION( 2,6,22 ))
+      pDev->udev->reset_resume = 1;
+#endif
+   }
+   
+   // Run usbnet's suspend function
+   return usbnet_suspend( pIntf, powerEvent );
+}
+   
+/*===========================================================================
+METHOD:
+   GobiNetResume (Public Method)
+
+DESCRIPTION:
+   Resume QMI traffic or recreate QMI device
+
+PARAMETERS
+   pIntf          [ I ] - Pointer to interface
+
+RETURN VALUE:
+   int - 0 for success
+         negative errno for failure
+===========================================================================*/
+int GobiNetResume( struct usb_interface * pIntf )
+{
+   struct usbnet * pDev;
+   sGobiUSBNet * pGobiDev;
+   int nRet;
+   int oldPowerState;
+   
+   if (pIntf == 0)
+   {
+      return -ENOMEM;
+   }
+   
+#if (LINUX_VERSION_CODE > KERNEL_VERSION( 2,6,23 ))
+   pDev = usb_get_intfdata( pIntf );
+#else
+   pDev = (struct usbnet *)pIntf->dev.platform_data;
+#endif
+
+   if (pDev == NULL || pDev->net == NULL)
+   {
+      DBG( "failed to get netdevice\n" );
+      return -ENXIO;
+   }
+   
+   pGobiDev = (sGobiUSBNet *)pDev->data[0];
+   if (pGobiDev == NULL)
+   {
+      DBG( "failed to get QMIDevice\n" );
+      return -ENXIO;
+   }
+
+   oldPowerState = pIntf->dev.power.power_state.event;
+   pIntf->dev.power.power_state.event = PM_EVENT_ON;
+   DBG( "resuming from power mode %d\n", oldPowerState );
+
+   if (oldPowerState & PM_EVENT_SUSPEND)
+   {
+      // It doesn't matter if this is autoresume or system resume
+      GobiClearDownReason( pGobiDev, DRIVER_SUSPENDED );
+   
+      nRet = usbnet_resume( pIntf );
+      if (nRet != 0)
+      {
+         DBG( "usbnet_resume error %d\n", nRet );
+         return nRet;
+      }
+
+      // Restart QMI read callbacks
+      nRet = StartRead( pGobiDev );
+      if (nRet != 0)
+      {
+         DBG( "StartRead error %d\n", nRet );
+         return nRet;
+      }
+
+#ifdef CONFIG_PM
+   #if (LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,29 ))   
+      // Kick Auto PM thread to process any queued URBs
+      complete( &pGobiDev->mAutoPM.mThreadDoWork );
+    #endif
+#endif /* CONFIG_PM */
+   }
+   else
+   {
+      DBG( "nothing to resume\n" );
+      return 0;
+   }
+   
+   return nRet;
+}
+#endif /* CONFIG_PM */
+
+/*===========================================================================
+METHOD:
+   GobiNetDriverBind (Public Method)
+
+DESCRIPTION:
+   Setup in and out pipes
+
+PARAMETERS
+   pDev           [ I ] - Pointer to usbnet device
+   pIntf          [ I ] - Pointer to interface
+
+RETURN VALUE:
+   int - 0 for success
+         Negative errno for error
+===========================================================================*/
+static int GobiNetDriverBind( 
+   struct usbnet *         pDev, 
+   struct usb_interface *  pIntf )
+{
+   int numEndpoints;
+   int endpointIndex;
+   struct usb_host_endpoint * pEndpoint = NULL;
+   struct usb_host_endpoint * pIn = NULL;
+   struct usb_host_endpoint * pOut = NULL;
+  
+   // Verify one altsetting
+   if (pIntf->num_altsetting != 1)
+   {
+      DBG( "invalid num_altsetting %u\n", pIntf->num_altsetting );
+      return -ENODEV;
+   }
+
+   // Verify correct interface (4 for NL650/NL660)
+   if (pDev->udev->descriptor.idVendor == NODECOM_VENDOR_ID 
+        && pDev->udev->descriptor.idProduct == cpu_to_le16(0x1001))
+   {
+        if (pIntf->cur_altsetting->desc.bInterfaceNumber != 4)
+            return -ENODEV;
+   }
+   else if (pDev->udev->descriptor.idVendor == NODECOM_VENDOR_ID 
+       && pDev->udev->descriptor.idProduct == cpu_to_le16(0x1000))
+   {
+       if (pIntf->cur_altsetting->desc.bInterfaceNumber != 2)
+            return -ENODEV;
+   }
+   else if (pDev->udev->descriptor.idVendor == FIBOCOM_VENDOR_ID 
+       && pDev->udev->descriptor.idProduct == cpu_to_le16(0x0104))
+   {
+       if (pIntf->cur_altsetting->desc.bInterfaceNumber != 4)
+            return -ENODEV;
+       DBG( "found gobinet infterface,vid:0x%x infc %d\n",pIntf->cur_altsetting->desc.bInterfaceNumber , pIntf->cur_altsetting->desc.bInterfaceNumber );
+   }
+   else if (pDev->udev->descriptor.idVendor == FIBOCOM_VENDOR_ID 
+       && pDev->udev->descriptor.idProduct == cpu_to_le16(0x0109))
+   {
+       if (pIntf->cur_altsetting->desc.bInterfaceNumber != 2)
+            return -ENODEV;
+   }
+   else if (pDev->udev->descriptor.idVendor == QUALCOMM_VENDOR_ID 
+       && pDev->udev->descriptor.idProduct == cpu_to_le16(0x90DB))
+   {
+       if (pIntf->cur_altsetting->desc.bInterfaceNumber != 2)
+            return -ENODEV;
+   }
+   else if ( pIntf->cur_altsetting->desc.bInterfaceNumber != 4 && pIntf->cur_altsetting->desc.bInterfaceNumber != 2)
+   {
+      DBG( "invalid interface %d\n", 
+           pIntf->cur_altsetting->desc.bInterfaceNumber );
+      return -ENODEV;
+   }
+
+   SetDeviceInterfaceNumber(pIntf->cur_altsetting->desc.bInterfaceNumber);
+
+   // Collect In and Out endpoints
+   numEndpoints = pIntf->cur_altsetting->desc.bNumEndpoints;
+   for (endpointIndex = 0; endpointIndex < numEndpoints; endpointIndex++)
+   {
+      pEndpoint = pIntf->cur_altsetting->endpoint + endpointIndex;
+      if (pEndpoint == NULL)
+      {
+         DBG( "invalid endpoint %u\n", endpointIndex );
+         return -ENODEV;
+      }
+
+      if (usb_endpoint_dir_in( &pEndpoint->desc ) == true
+      &&  usb_endpoint_xfer_int( &pEndpoint->desc ) == false)
+      {
+         pIn = pEndpoint;
+      }
+      else if (usb_endpoint_dir_out( &pEndpoint->desc ) == true)
+      {
+         pOut = pEndpoint;
+      }
+   }
+   
+   if (pIn == NULL || pOut == NULL)
+   {
+      DBG( "invalid endpoints\n" );
+      return -ENODEV;
+   }
+
+   if (usb_set_interface( pDev->udev, 
+                          pIntf->cur_altsetting->desc.bInterfaceNumber,
+                          0 ) != 0)
+   {
+      DBG( "unable to set interface[%d]\n",pIntf->cur_altsetting->desc.bInterfaceNumber );
+      return -ENODEV;
+   }
+   DBG( "set interface[%d] ok\n",pIntf->cur_altsetting->desc.bInterfaceNumber );
+   pDev->in = usb_rcvbulkpipe( pDev->udev,
+                   pIn->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK );
+   pDev->out = usb_sndbulkpipe( pDev->udev,
+                   pOut->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK );
+
+#if 1 //def DATA_MODE_RP
+    /* make MAC addr easily distinguishable from an IP header */
+    if ((pDev->net->dev_addr[0] & 0xd0) == 0x40) {
+        /*clear this bit wil make usbnet apdater named as usbX(instead if ethX)*/
+        pDev->net->dev_addr[0] |= 0x02;	/* set local assignment bit */
+        pDev->net->dev_addr[0] &= 0xbf;	/* clear "IP" bit */
+    }
+#endif
+                   
+   DBG( "in %x, out %x\n", 
+        pIn->desc.bEndpointAddress, 
+        pOut->desc.bEndpointAddress );
+
+   // In later versions of the kernel, usbnet helps with this
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION( 2,6,23 ))
+   pIntf->dev.platform_data = (void *)pDev;
+#endif
+
+   return 0;
+}
+
+/*===========================================================================
+METHOD:
+   GobiNetDriverUnbind (Public Method)
+
+DESCRIPTION:
+   Deregisters QMI device (Registration happened in the probe function)
+
+PARAMETERS
+   pDev           [ I ] - Pointer to usbnet device
+   pIntfUnused    [ I ] - Pointer to interface
+
+RETURN VALUE:
+   None
+===========================================================================*/
+static void GobiNetDriverUnbind( 
+   struct usbnet *         pDev, 
+   struct usb_interface *  pIntf)
+{
+   sGobiUSBNet * pGobiDev = (sGobiUSBNet *)pDev->data[0];
+
+   // Should already be down, but just in case...
+   netif_carrier_off( pDev->net );
+
+   DeregisterQMIDevice( pGobiDev );
+   
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION( 2,6,29 ))
+   kfree( pDev->net->netdev_ops );
+   pDev->net->netdev_ops = NULL;
+#endif
+
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION( 2,6,23 ))
+   pIntf->dev.platform_data = NULL;
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION( 2,6,19 ))
+   pIntf->needs_remote_wakeup = 0;
+#endif
+
+   if (atomic_dec_and_test(&pGobiDev->refcount))
+      kfree( pGobiDev );
+   else
+      DBG("memory leak!\n");
+}
+
+#if 1 //def DATA_MODE_RP
+/*===========================================================================
+METHOD:
+   GobiNetDriverTxFixup (Public Method)
+
+DESCRIPTION:
+   Handling data format mode on transmit path
+
+PARAMETERS
+   pDev           [ I ] - Pointer to usbnet device
+   pSKB           [ I ] - Pointer to transmit packet buffer
+   flags          [ I ] - os flags
+
+RETURN VALUE:
+   None
+===========================================================================*/
+struct sk_buff *GobiNetDriverTxFixup(struct usbnet *dev, struct sk_buff *skb, gfp_t flags)
+{
+    sGobiUSBNet * pGobiDev = (sGobiUSBNet *)dev->data[0];
+
+    if (!pGobiDev->mbRawIPMode)
+        return skb;
+        
+    // Skip Ethernet header from message
+    if (skb_pull(skb, ETH_HLEN)) {
+        return skb;
+    } else {
+        dev_err(&dev->intf->dev,  "Packet Dropped ");
+    }
+    
+   // Filter the packet out, release it
+   dev_kfree_skb_any(skb);
+   return NULL;
+}
+
+/*===========================================================================
+METHOD:
+   GobiNetDriverRxFixup (Public Method)
+
+DESCRIPTION:
+   Handling data format mode on receive path
+
+PARAMETERS
+   pDev           [ I ] - Pointer to usbnet device
+   pSKB           [ I ] - Pointer to received packet buffer
+
+RETURN VALUE:
+   None
+===========================================================================*/
+static int GobiNetDriverRxFixup(struct usbnet *dev, struct sk_buff *skb)
+{
+    __be16 proto;
+    sGobiUSBNet * pGobiDev = (sGobiUSBNet *)dev->data[0];
+
+    if (!pGobiDev->mbRawIPMode)
+        return 1;
+
+    /* This check is no longer done by usbnet */
+    if (skb->len < dev->net->hard_header_len)
+		return 0;
+
+    switch (skb->data[0] & 0xf0) {
+    case 0x40:
+    	proto = htons(ETH_P_IP);
+    	break;
+    case 0x60:
+    	proto = htons(ETH_P_IPV6);
+    	break;
+    case 0x00:
+    	if (is_multicast_ether_addr(skb->data))
+    		return 1;
+    	/* possibly bogus destination - rewrite just in case */
+    	skb_reset_mac_header(skb);
+    	goto fix_dest;
+    default:
+    	/* pass along other packets without modifications */
+    	return 1;
+    }
+    if (skb_headroom(skb) < ETH_HLEN && pskb_expand_head(skb, ETH_HLEN, 0, GFP_ATOMIC)) {
+        DBG("%s: couldn't pskb_expand_head\n", __func__);
+        return 0;
+    }
+    skb_push(skb, ETH_HLEN);
+    skb_reset_mac_header(skb);
+    eth_hdr(skb)->h_proto = proto;
+    memset(eth_hdr(skb)->h_source, 0, ETH_ALEN);
+fix_dest:
+    memcpy(eth_hdr(skb)->h_dest, dev->net->dev_addr, ETH_ALEN);
+    return 1;
+}
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,29 ))
+#ifdef CONFIG_PM
+/*===========================================================================
+METHOD:
+   GobiUSBNetURBCallback (Public Method)
+
+DESCRIPTION:
+   Write is complete, cleanup and signal that we're ready for next packet
+
+PARAMETERS
+   pURB     [ I ] - Pointer to sAutoPM struct
+
+RETURN VALUE:
+   None
+===========================================================================*/
+#if (LINUX_VERSION_CODE > KERNEL_VERSION( 2,6,14 ))
+void GobiUSBNetURBCallback( struct urb * pURB )
+#else
+void GobiUSBNetURBCallback(struct urb *pURB, struct pt_regs *regs)
+#endif
+{
+   unsigned long activeURBflags;
+   sAutoPM * pAutoPM = (sAutoPM *)pURB->context;
+   if (pAutoPM == NULL)
+   {
+      // Should never happen
+      DBG( "bad context\n" );
+      return;
+   }
+
+   if (pURB->status != 0)
+   {
+      // Note that in case of an error, the behaviour is no different
+      DBG( "urb finished with error %d\n", pURB->status );
+   }
+
+   // Remove activeURB (memory to be freed later)
+   spin_lock_irqsave( &pAutoPM->mActiveURBLock, activeURBflags );
+
+   // EAGAIN used to signify callback is done
+   pAutoPM->mpActiveURB = ERR_PTR( -EAGAIN );
+
+   spin_unlock_irqrestore( &pAutoPM->mActiveURBLock, activeURBflags );
+
+   complete( &pAutoPM->mThreadDoWork );
+   
+   usb_free_urb( pURB );
+}
+
+/*===========================================================================
+METHOD:
+   GobiUSBNetTXTimeout (Public Method)
+
+DESCRIPTION:
+   Timeout declared by the net driver.  Stop all transfers
+
+PARAMETERS
+   pNet     [ I ] - Pointer to net device
+
+RETURN VALUE:
+   None
+===========================================================================*/
+void GobiUSBNetTXTimeout( struct net_device * pNet )
+{
+   struct sGobiUSBNet * pGobiDev;
+   sAutoPM * pAutoPM;
+   sURBList * pURBListEntry;
+   unsigned long activeURBflags, URBListFlags;
+   struct usbnet * pDev = netdev_priv( pNet );
+   struct urb * pURB;
+
+   if (pDev == NULL || pDev->net == NULL)
+   {
+      DBG( "failed to get usbnet device\n" );
+      return;
+   }
+   
+   pGobiDev = (sGobiUSBNet *)pDev->data[0];
+   if (pGobiDev == NULL)
+   {
+      DBG( "failed to get QMIDevice\n" );
+      return;
+   }
+   pAutoPM = &pGobiDev->mAutoPM;
+
+   DBG( "\n" );
+
+   // Grab a pointer to active URB
+   spin_lock_irqsave( &pAutoPM->mActiveURBLock, activeURBflags );
+   pURB = pAutoPM->mpActiveURB;
+   spin_unlock_irqrestore( &pAutoPM->mActiveURBLock, activeURBflags );
+   // Stop active URB
+   if (pURB != NULL)
+   {
+      usb_kill_urb( pURB );
+   }
+
+   // Cleanup URB List
+   spin_lock_irqsave( &pAutoPM->mURBListLock, URBListFlags );
+
+   pURBListEntry = pAutoPM->mpURBList;
+   while (pURBListEntry != NULL)
+   {
+      pAutoPM->mpURBList = pAutoPM->mpURBList->mpNext;
+      atomic_dec( &pAutoPM->mURBListLen );
+      usb_free_urb( pURBListEntry->mpURB );
+      kfree( pURBListEntry );
+      pURBListEntry = pAutoPM->mpURBList;
+   }
+
+   spin_unlock_irqrestore( &pAutoPM->mURBListLock, URBListFlags );
+
+   complete( &pAutoPM->mThreadDoWork );
+
+   return;
+}
+
+/*===========================================================================
+METHOD:
+   GobiUSBNetAutoPMThread (Public Method)
+
+DESCRIPTION:
+   Handle device Auto PM state asynchronously
+   Handle network packet transmission asynchronously
+
+PARAMETERS
+   pData     [ I ] - Pointer to sAutoPM struct
+
+RETURN VALUE:
+   int - 0 for success
+         Negative errno for error
+===========================================================================*/
+static int GobiUSBNetAutoPMThread( void * pData )
+{
+   unsigned long activeURBflags, URBListFlags;
+   sURBList * pURBListEntry;
+   int status;
+   struct usb_device * pUdev;
+   sAutoPM * pAutoPM = (sAutoPM *)pData;
+   struct urb * pURB;
+
+   if (pAutoPM == NULL)
+   {
+      DBG( "passed null pointer\n" );
+      return -EINVAL;
+   }
+   
+   pUdev = interface_to_usbdev( pAutoPM->mpIntf );
+
+   DBG( "traffic thread started\n" );
+
+   while (pAutoPM->mbExit == false)
+   {
+      // Wait for someone to poke us
+      wait_for_completion_interruptible( &pAutoPM->mThreadDoWork );
+
+      // Time to exit?
+      if (pAutoPM->mbExit == true)
+      {
+         // Stop activeURB
+         spin_lock_irqsave( &pAutoPM->mActiveURBLock, activeURBflags );
+         pURB = pAutoPM->mpActiveURB;
+         spin_unlock_irqrestore( &pAutoPM->mActiveURBLock, activeURBflags );
+
+         // EAGAIN used to signify callback is done
+         if (IS_ERR( pAutoPM->mpActiveURB )
+                 &&  PTR_ERR( pAutoPM->mpActiveURB ) == -EAGAIN )
+         {
+             pURB = NULL;
+         }
+
+         if (pURB != NULL)
+         {
+            usb_kill_urb( pURB );
+         }
+         // Will be freed in callback function
+
+         // Cleanup URB List
+         spin_lock_irqsave( &pAutoPM->mURBListLock, URBListFlags );
+
+         pURBListEntry = pAutoPM->mpURBList;
+         while (pURBListEntry != NULL)
+         {
+            pAutoPM->mpURBList = pAutoPM->mpURBList->mpNext;
+            atomic_dec( &pAutoPM->mURBListLen );
+            usb_free_urb( pURBListEntry->mpURB );
+            kfree( pURBListEntry );
+            pURBListEntry = pAutoPM->mpURBList;
+         }
+
+         spin_unlock_irqrestore( &pAutoPM->mURBListLock, URBListFlags );
+
+         break;
+      }
+      
+      // Is our URB active?
+      spin_lock_irqsave( &pAutoPM->mActiveURBLock, activeURBflags );
+
+      // EAGAIN used to signify callback is done
+      if (IS_ERR( pAutoPM->mpActiveURB ) 
+      &&  PTR_ERR( pAutoPM->mpActiveURB ) == -EAGAIN )
+      {
+         pAutoPM->mpActiveURB = NULL;
+
+         // Restore IRQs so task can sleep
+         spin_unlock_irqrestore( &pAutoPM->mActiveURBLock, activeURBflags );
+         
+         // URB is done, decrement the Auto PM usage count
+         usb_autopm_put_interface( pAutoPM->mpIntf );
+
+         // Lock ActiveURB again
+         spin_lock_irqsave( &pAutoPM->mActiveURBLock, activeURBflags );
+      }
+
+      if (pAutoPM->mpActiveURB != NULL)
+      {
+         // There is already a URB active, go back to sleep
+         spin_unlock_irqrestore( &pAutoPM->mActiveURBLock, activeURBflags );
+         continue;
+      }
+      
+      // Is there a URB waiting to be submitted?
+      spin_lock_irqsave( &pAutoPM->mURBListLock, URBListFlags );
+      if (pAutoPM->mpURBList == NULL)
+      {
+         // No more URBs to submit, go back to sleep
+         spin_unlock_irqrestore( &pAutoPM->mURBListLock, URBListFlags );
+         spin_unlock_irqrestore( &pAutoPM->mActiveURBLock, activeURBflags );
+         continue;
+      }
+
+      // Pop an element
+      pURBListEntry = pAutoPM->mpURBList;
+      pAutoPM->mpURBList = pAutoPM->mpURBList->mpNext;
+      atomic_dec( &pAutoPM->mURBListLen );
+      spin_unlock_irqrestore( &pAutoPM->mURBListLock, URBListFlags );
+
+      // Set ActiveURB
+      pAutoPM->mpActiveURB = pURBListEntry->mpURB;
+      spin_unlock_irqrestore( &pAutoPM->mActiveURBLock, activeURBflags );
+
+      // Tell autopm core we need device woken up
+      status = usb_autopm_get_interface( pAutoPM->mpIntf );
+      if (status < 0)
+      {
+         DBG( "unable to autoresume interface: %d\n", status );
+
+         // likely caused by device going from autosuspend -> full suspend
+         if (status == -EPERM)
+         {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,33 ))
+#if (LINUX_VERSION_CODE > KERNEL_VERSION( 2,6,14 ))
+            pUdev->auto_pm = 0;
+#else
+             pUdev = pUdev;
+#endif
+#endif
+            GobiNetSuspend( pAutoPM->mpIntf, PMSG_SUSPEND );
+         }
+
+         // Add pURBListEntry back onto pAutoPM->mpURBList
+         spin_lock_irqsave( &pAutoPM->mURBListLock, URBListFlags );
+         pURBListEntry->mpNext = pAutoPM->mpURBList;
+         pAutoPM->mpURBList = pURBListEntry;
+         atomic_inc( &pAutoPM->mURBListLen );
+         spin_unlock_irqrestore( &pAutoPM->mURBListLock, URBListFlags );
+         
+         spin_lock_irqsave( &pAutoPM->mActiveURBLock, activeURBflags );
+         pAutoPM->mpActiveURB = NULL;
+         spin_unlock_irqrestore( &pAutoPM->mActiveURBLock, activeURBflags );
+         
+         // Go back to sleep
+         continue;
+      }
+
+      // Submit URB
+      status = usb_submit_urb( pAutoPM->mpActiveURB, GFP_KERNEL );
+      if (status < 0)
+      {
+         // Could happen for a number of reasons
+         DBG( "Failed to submit URB: %d.  Packet dropped\n", status );
+         spin_lock_irqsave( &pAutoPM->mActiveURBLock, activeURBflags );
+         usb_free_urb( pAutoPM->mpActiveURB );
+         pAutoPM->mpActiveURB = NULL;
+         spin_unlock_irqrestore( &pAutoPM->mActiveURBLock, activeURBflags );
+         usb_autopm_put_interface( pAutoPM->mpIntf );
+
+         // Loop again
+         complete( &pAutoPM->mThreadDoWork );
+      }
+      
+      kfree( pURBListEntry );
+   }   
+   
+   DBG( "traffic thread exiting\n" );
+   pAutoPM->mpThread = NULL;
+   return 0;
+}      
+
+/*===========================================================================
+METHOD:
+   GobiUSBNetStartXmit (Public Method)
+
+DESCRIPTION:
+   Convert sk_buff to usb URB and queue for transmit
+
+PARAMETERS
+   pNet     [ I ] - Pointer to net device
+
+RETURN VALUE:
+   NETDEV_TX_OK on success
+   NETDEV_TX_BUSY on error
+===========================================================================*/
+int GobiUSBNetStartXmit( 
+   struct sk_buff *     pSKB,
+   struct net_device *  pNet )
+{
+   unsigned long URBListFlags;
+   struct sGobiUSBNet * pGobiDev;
+   sAutoPM * pAutoPM;
+   sURBList * pURBListEntry, ** ppURBListEnd;
+   void * pURBData;
+   struct usbnet * pDev = netdev_priv( pNet );
+   
+   //DBG( "\n" );
+   
+   if (pDev == NULL || pDev->net == NULL)
+   {
+      DBG( "failed to get usbnet device\n" );
+      return NETDEV_TX_BUSY;
+   }
+   
+   pGobiDev = (sGobiUSBNet *)pDev->data[0];
+   if (pGobiDev == NULL)
+   {
+      DBG( "failed to get QMIDevice\n" );
+      return NETDEV_TX_BUSY;
+   }
+   pAutoPM = &pGobiDev->mAutoPM;
+   
+   if( NULL == pSKB )
+   {
+       DBG( "Buffer is NULL \n" );
+       return NETDEV_TX_BUSY;
+   }
+
+   if (GobiTestDownReason( pGobiDev, DRIVER_SUSPENDED ) == true)
+   {
+      // Should not happen
+      DBG( "device is suspended\n" );
+      dump_stack();
+      return NETDEV_TX_BUSY;
+   }
+   
+   if (GobiTestDownReason( pGobiDev, NO_NDIS_CONNECTION ))
+   {
+      //netif_carrier_off( pGobiDev->mpNetDev->net );
+      //DBG( "device is disconnected\n" );
+      //dump_stack();
+      return NETDEV_TX_BUSY;
+   }
+   
+   // Convert the sk_buff into a URB
+
+   // Check if buffer is full
+   if ( atomic_read( &pAutoPM->mURBListLen ) >= txQueueLength)
+   {
+      DBG( "not scheduling request, buffer is full\n" );
+      return NETDEV_TX_BUSY;
+   }
+
+   // Allocate URBListEntry
+   pURBListEntry = kmalloc( sizeof( sURBList ), GFP_ATOMIC );
+   if (pURBListEntry == NULL)
+   {
+      DBG( "unable to allocate URBList memory\n" );
+      return NETDEV_TX_BUSY;
+   }
+   pURBListEntry->mpNext = NULL;
+
+   // Allocate URB
+   pURBListEntry->mpURB = usb_alloc_urb( 0, GFP_ATOMIC );
+   if (pURBListEntry->mpURB == NULL)
+   {
+      DBG( "unable to allocate URB\n" );
+      // release all memory allocated by now 
+      if (pURBListEntry)
+         kfree( pURBListEntry );
+      return NETDEV_TX_BUSY;
+   }
+
+#if 1 //def DATA_MODE_RP
+   GobiNetDriverTxFixup(pNet, pSKB, GFP_ATOMIC);	
+#endif
+
+   // Allocate URB transfer_buffer
+   pURBData = kmalloc( pSKB->len, GFP_ATOMIC );
+   if (pURBData == NULL)
+   {
+      DBG( "unable to allocate URB data\n" );
+      // release all memory allocated by now
+      if (pURBListEntry)
+      {
+         usb_free_urb( pURBListEntry->mpURB );
+         kfree( pURBListEntry );
+      }
+      return NETDEV_TX_BUSY;
+   }
+   // Fill with SKB's data
+   memcpy( pURBData, pSKB->data, pSKB->len );
+
+   usb_fill_bulk_urb( pURBListEntry->mpURB,
+                      pGobiDev->mpNetDev->udev,
+                      pGobiDev->mpNetDev->out,
+                      pURBData,
+                      pSKB->len,
+                      GobiUSBNetURBCallback,
+                      pAutoPM );
+
+   /* Handle the need to send a zero length packet and release the
+    * transfer buffer
+    */
+    pURBListEntry->mpURB->transfer_flags |= (URB_ZERO_PACKET | URB_FREE_BUFFER);
+
+   // Aquire lock on URBList
+   spin_lock_irqsave( &pAutoPM->mURBListLock, URBListFlags );
+   
+   // Add URB to end of list
+   ppURBListEnd = &pAutoPM->mpURBList;
+   while ((*ppURBListEnd) != NULL)
+   {
+      ppURBListEnd = &(*ppURBListEnd)->mpNext;
+   }
+   *ppURBListEnd = pURBListEntry;
+   atomic_inc( &pAutoPM->mURBListLen );
+
+   spin_unlock_irqrestore( &pAutoPM->mURBListLock, URBListFlags );
+
+   complete( &pAutoPM->mThreadDoWork );
+
+   // Start transfer timer
+   pNet->trans_start = jiffies;
+   // Free SKB
+   if (pSKB)
+      dev_kfree_skb_any( pSKB );
+
+   return NETDEV_TX_OK;
+}
+#endif
+static int (*local_usbnet_start_xmit) (struct sk_buff *skb, struct net_device *net);
+#endif
+
+static int GobiUSBNetStartXmit2( struct sk_buff *pSKB, struct net_device *pNet ){
+   struct sGobiUSBNet * pGobiDev;
+   struct usbnet * pDev = netdev_priv( pNet );
+   
+   //DBG( "\n" );
+   
+   if (pDev == NULL || pDev->net == NULL)
+   {
+      DBG( "failed to get usbnet device\n" );
+      return NETDEV_TX_BUSY;
+   }
+   
+   pGobiDev = (sGobiUSBNet *)pDev->data[0];
+   if (pGobiDev == NULL)
+   {
+      DBG( "failed to get QMIDevice\n" );
+      return NETDEV_TX_BUSY;
+   }
+   
+   if( NULL == pSKB )
+   {
+       DBG( "Buffer is NULL \n" );
+       return NETDEV_TX_BUSY;
+   }
+
+   if (GobiTestDownReason( pGobiDev, DRIVER_SUSPENDED ) == true)
+   {
+      // Should not happen
+      DBG( "device is suspended\n" );
+      dump_stack();
+      return NETDEV_TX_BUSY;
+   }
+   
+   if (GobiTestDownReason( pGobiDev, NO_NDIS_CONNECTION ))
+   {
+      //netif_carrier_off( pGobiDev->mpNetDev->net );
+      //DBG( "device is disconnected\n" );
+      //dump_stack();
+      return NETDEV_TX_BUSY;
+   }
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,29 ))
+   return local_usbnet_start_xmit(pSKB, pNet);
+#else
+   return usbnet_start_xmit(pSKB, pNet);
+#endif
+}
+
+/*===========================================================================
+METHOD:
+   GobiUSBNetOpen (Public Method)
+
+DESCRIPTION:
+   Wrapper to usbnet_open, correctly handling autosuspend
+   Start AutoPM thread (if CONFIG_PM is defined)
+
+PARAMETERS
+   pNet     [ I ] - Pointer to net device
+
+RETURN VALUE:
+   int - 0 for success
+         Negative errno for error
+===========================================================================*/
+int GobiUSBNetOpen( struct net_device * pNet )
+{
+   int status = 0;
+   struct sGobiUSBNet * pGobiDev;
+   struct usbnet * pDev = netdev_priv( pNet );
+
+   if (pDev == NULL)
+   {
+      DBG( "failed to get usbnet device\n" );
+      return -ENXIO;
+   }
+
+   pGobiDev = (sGobiUSBNet *)pDev->data[0];
+   if (pGobiDev == NULL)
+   {
+      DBG( "failed to get QMIDevice\n" );
+      return -ENXIO;
+   }
+
+   DBG( "\n" );
+
+#ifdef CONFIG_PM
+   #if (LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,29 ))
+   // Start the AutoPM thread
+   pGobiDev->mAutoPM.mpIntf = pGobiDev->mpIntf;
+   pGobiDev->mAutoPM.mbExit = false;
+   pGobiDev->mAutoPM.mpURBList = NULL;
+   pGobiDev->mAutoPM.mpActiveURB = NULL;
+   spin_lock_init( &pGobiDev->mAutoPM.mURBListLock );
+   spin_lock_init( &pGobiDev->mAutoPM.mActiveURBLock );
+   atomic_set( &pGobiDev->mAutoPM.mURBListLen, 0 );
+   init_completion( &pGobiDev->mAutoPM.mThreadDoWork );
+   
+   pGobiDev->mAutoPM.mpThread = kthread_run( GobiUSBNetAutoPMThread, 
+                                               &pGobiDev->mAutoPM, 
+                                               "GobiUSBNetAutoPMThread" );
+   if (IS_ERR( pGobiDev->mAutoPM.mpThread ))
+   {
+      DBG( "AutoPM thread creation error\n" );
+      return PTR_ERR( pGobiDev->mAutoPM.mpThread );
+   }
+   #endif
+#endif /* CONFIG_PM */
+
+   // Allow traffic
+   GobiClearDownReason( pGobiDev, NET_IFACE_STOPPED );
+
+   // Pass to usbnet_open if defined
+   if (pGobiDev->mpUSBNetOpen != NULL)
+   {
+      status = pGobiDev->mpUSBNetOpen( pNet );
+#ifdef CONFIG_PM
+      // If usbnet_open was successful enable Auto PM
+      if (status == 0)
+      {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,33 ))
+         usb_autopm_enable( pGobiDev->mpIntf );
+#else
+         usb_autopm_put_interface( pGobiDev->mpIntf );
+#endif
+      }
+#endif /* CONFIG_PM */
+   }
+   else
+   {
+      DBG( "no USBNetOpen defined\n" );
+   }
+   
+   return status;
+}
+
+/*===========================================================================
+METHOD:
+   GobiUSBNetStop (Public Method)
+
+DESCRIPTION:
+   Wrapper to usbnet_stop, correctly handling autosuspend
+   Stop AutoPM thread (if CONFIG_PM is defined)
+
+PARAMETERS
+   pNet     [ I ] - Pointer to net device
+
+RETURN VALUE:
+   int - 0 for success
+         Negative errno for error
+===========================================================================*/
+int GobiUSBNetStop( struct net_device * pNet )
+{
+   struct sGobiUSBNet * pGobiDev;
+   struct usbnet * pDev = netdev_priv( pNet );
+
+   if (pDev == NULL || pDev->net == NULL)
+   {
+      DBG( "failed to get netdevice\n" );
+      return -ENXIO;
+   }
+
+   pGobiDev = (sGobiUSBNet *)pDev->data[0];
+   if (pGobiDev == NULL)
+   {
+      DBG( "failed to get QMIDevice\n" );
+      return -ENXIO;
+   }
+
+   // Stop traffic
+   GobiSetDownReason( pGobiDev, NET_IFACE_STOPPED );
+
+#ifdef CONFIG_PM
+   #if (LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,29 ))
+   // Tell traffic thread to exit
+   pGobiDev->mAutoPM.mbExit = true;
+   complete( &pGobiDev->mAutoPM.mThreadDoWork );
+
+   // Wait for it to exit
+   while( pGobiDev->mAutoPM.mpThread != NULL )
+   {
+      msleep( 100 );
+   }
+   DBG( "thread stopped\n" );
+   #endif
+#endif /* CONFIG_PM */
+
+   // Pass to usbnet_stop, if defined
+   if (pGobiDev->mpUSBNetStop != NULL)
+   {
+      return pGobiDev->mpUSBNetStop( pNet );
+   }
+   else
+   {
+      return 0;
+   }
+}
+
+/*=========================================================================*/
+// Struct driver_info
+/*=========================================================================*/
+static const struct driver_info GobiNetInfo = 
+{
+   .description   = "GobiNet Ethernet Device",
+   .flags         = FLAG_ETHER | FLAG_POINTTOPOINT,
+   .bind          = GobiNetDriverBind,
+   .unbind        = GobiNetDriverUnbind,
+#if 1 //def DATA_MODE_RP
+   .rx_fixup      = GobiNetDriverRxFixup,
+   .tx_fixup      = GobiNetDriverTxFixup,
+#endif
+   .data          = 0,
+};
+
+/*=========================================================================*/
+// Qualcomm Gobi 3000 VID/PIDs
+/*=========================================================================*/
+static const struct usb_device_id GobiVIDPIDTable [] =
+{
+   // Fibocom NL678
+   { 
+      USB_DEVICE( 0x2CB7, 0x0104 ),
+      .driver_info = (unsigned long)&GobiNetInfo 
+   },
+   { 
+      USB_DEVICE( 0x2CB7, 0x0109 ),
+      .driver_info = (unsigned long)&GobiNetInfo 
+   },
+   { 
+      USB_DEVICE( 0x05C6, 0x90DB ),
+      .driver_info = (unsigned long)&GobiNetInfo 
+   },
+   { 
+      USB_DEVICE( 0x1508, 0x1001 ),
+      .driver_info = (unsigned long)&GobiNetInfo 
+   },
+   { 
+      USB_DEVICE( 0x1508, 0x1000 ),
+      .driver_info = (unsigned long)&GobiNetInfo 
+   },
+   { 
+      USB_DEVICE( 0x2C7C, 0x0306 ),
+      .driver_info = (unsigned long)&GobiNetInfo 
+   },
+   //Terminating entry
+   { }
+};
+
+MODULE_DEVICE_TABLE( usb, GobiVIDPIDTable );
+
+/*===========================================================================
+METHOD:
+   GobiUSBNetProbe (Public Method)
+
+DESCRIPTION:
+   Run usbnet_probe
+   Setup QMI device
+
+PARAMETERS
+   pIntf        [ I ] - Pointer to interface
+   pVIDPIDs     [ I ] - Pointer to VID/PID table
+
+RETURN VALUE:
+   int - 0 for success
+         Negative errno for error
+===========================================================================*/
+int GobiUSBNetProbe( 
+   struct usb_interface *        pIntf, 
+   const struct usb_device_id *  pVIDPIDs )
+{
+   int status;
+   struct usbnet * pDev;
+   sGobiUSBNet * pGobiDev;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION( 2,6,29 ))
+   struct net_device_ops * pNetDevOps;
+#endif   
+
+   status = usbnet_probe( pIntf, pVIDPIDs );
+   if (status < 0)
+   {
+      DBG( "usbnet_probe failed %d\n", status );
+	  return status; 
+   }
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION( 2,6,19 ))
+   pIntf->needs_remote_wakeup = 1;
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION( 2,6,23 ))
+   pDev = usb_get_intfdata( pIntf );
+#else
+   pDev = (struct usbnet *)pIntf->dev.platform_data;
+#endif
+
+   if (pDev == NULL || pDev->net == NULL)
+   {
+      DBG( "failed to get netdevice\n" );
+      usbnet_disconnect( pIntf );
+      return -ENXIO;
+   }
+
+   pGobiDev = kzalloc( sizeof( sGobiUSBNet ), GFP_KERNEL );
+   if (pGobiDev == NULL)
+   {
+      DBG( "falied to allocate device buffers" );
+      usbnet_disconnect( pIntf );
+      return -ENOMEM;
+   }
+   
+   atomic_set(&pGobiDev->refcount, 1);
+
+   pDev->data[0] = (unsigned long)pGobiDev;
+   
+   pGobiDev->mpNetDev = pDev;
+
+   // Clearing endpoint halt is a magic handshake that brings 
+   // the device out of low power (airplane) mode
+   usb_clear_halt( pGobiDev->mpNetDev->udev, pDev->out );
+
+   // Overload PM related network functions
+#if (LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,29 ))
+   pGobiDev->mpUSBNetOpen = pDev->net->open;
+   pDev->net->open = GobiUSBNetOpen;
+   pGobiDev->mpUSBNetStop = pDev->net->stop;
+   pDev->net->stop = GobiUSBNetStop;
+#if defined(CONFIG_PM) && (LINUX_VERSION_CODE > KERNEL_VERSION( 2,6,14 ))
+   pDev->net->hard_start_xmit = GobiUSBNetStartXmit;
+   pDev->net->tx_timeout = GobiUSBNetTXTimeout;
+#else  //nodecom donot send dhcp request before ndis connect for uc20
+    local_usbnet_start_xmit = pDev->net->hard_start_xmit;
+    pDev->net->hard_start_xmit = GobiUSBNetStartXmit2;
+#endif
+#else
+   pNetDevOps = kmalloc( sizeof( struct net_device_ops ), GFP_KERNEL );
+   if (pNetDevOps == NULL)
+   {
+      DBG( "falied to allocate net device ops" );
+      usbnet_disconnect( pIntf );
+      return -ENOMEM;
+   }
+   memcpy( pNetDevOps, pDev->net->netdev_ops, sizeof( struct net_device_ops ) );
+   
+   pGobiDev->mpUSBNetOpen = pNetDevOps->ndo_open;
+   pNetDevOps->ndo_open = GobiUSBNetOpen;
+   pGobiDev->mpUSBNetStop = pNetDevOps->ndo_stop;
+   pNetDevOps->ndo_stop = GobiUSBNetStop;
+#if 1 //nodecom donot send dhcp request before ndis connect for uc20
+   pNetDevOps->ndo_start_xmit = GobiUSBNetStartXmit2;
+#else
+   pNetDevOps->ndo_start_xmit = usbnet_start_xmit;
+#endif
+   pNetDevOps->ndo_tx_timeout = usbnet_tx_timeout;
+
+   pDev->net->netdev_ops = pNetDevOps;
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,31 ))
+   memset( &(pGobiDev->mpNetDev->stats), 0, sizeof( struct net_device_stats ) );
+#else
+   memset( &(pGobiDev->mpNetDev->net->stats), 0, sizeof( struct net_device_stats ) );
+#endif
+
+   pGobiDev->mpIntf = pIntf;
+   memset( &(pGobiDev->mMEID), '0', 14 );
+   
+   DBG( "Mac Address:\n" );
+   PrintHex( &pGobiDev->mpNetDev->net->dev_addr[0], 6 );
+
+   pGobiDev->mbQMIValid = false;
+   memset( &pGobiDev->mQMIDev, 0, sizeof( sQMIDev ) );
+   pGobiDev->mQMIDev.mbCdevIsInitialized = false;
+
+   pGobiDev->mQMIDev.mpDevClass = gpClass;
+   
+#ifdef CONFIG_PM
+   #if (LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,29 ))
+   init_completion( &pGobiDev->mAutoPM.mThreadDoWork );
+   #endif
+#endif /* CONFIG_PM */
+   spin_lock_init( &pGobiDev->mQMIDev.mClientMemLock );
+
+   // Default to device down
+   pGobiDev->mDownReason = 0;
+
+//#if (LINUX_VERSION_CODE < KERNEL_VERSION( 3,11,0 ))
+   GobiSetDownReason( pGobiDev, NO_NDIS_CONNECTION );
+   GobiSetDownReason( pGobiDev, NET_IFACE_STOPPED );
+//#endif
+
+   // Register QMI
+   status = RegisterQMIDevice( pGobiDev );
+   if (status != 0)
+   {
+      // usbnet_disconnect() will call GobiNetDriverUnbind() which will call
+      // DeregisterQMIDevice() to clean up any partially created QMI device
+      usbnet_disconnect( pIntf );
+      return status;
+   }
+   
+   // Success
+   return 0;
+}
+
+static struct usb_driver GobiNet =
+{
+   .name       = "GobiNet",
+   .id_table   = GobiVIDPIDTable,
+   .probe      = GobiUSBNetProbe,
+   .disconnect = usbnet_disconnect,
+#ifdef CONFIG_PM
+   .suspend    = GobiNetSuspend,
+   .resume     = GobiNetResume,
+   /*Fibocom add for reset_resume*/
+   .reset_resume     = GobiNetResume,
+#if (LINUX_VERSION_CODE > KERNEL_VERSION( 2,6,14 ))   
+   .supports_autosuspend = true,
+#endif   
+#else
+   .suspend    = NULL,
+   .resume     = NULL,
+#if (LINUX_VERSION_CODE > KERNEL_VERSION( 2,6,14 ))   
+   .supports_autosuspend = false,
+#endif   
+#endif /* CONFIG_PM */
+};
+
+/*===========================================================================
+METHOD:
+   GobiUSBNetModInit (Public Method)
+
+DESCRIPTION:
+   Initialize module
+   Create device class
+   Register out usb_driver struct
+
+RETURN VALUE:
+   int - 0 for success
+         Negative errno for error
+===========================================================================*/
+static int __init GobiUSBNetModInit( void )
+{
+   gpClass = class_create( THIS_MODULE, "GobiQMI" );
+   if (IS_ERR( gpClass ) == true)
+   {
+      DBG( "error at class_create %ld\n",
+           PTR_ERR( gpClass ) );
+      return -ENOMEM;
+   }
+
+   // This will be shown whenever driver is loaded
+   printk( KERN_INFO "%s: %s\n", DRIVER_DESC, DRIVER_VERSION );
+
+   return usb_register( &GobiNet );
+}
+module_init( GobiUSBNetModInit );
+
+/*===========================================================================
+METHOD:
+   GobiUSBNetModExit (Public Method)
+
+DESCRIPTION:
+   Deregister module
+   Destroy device class
+
+RETURN VALUE:
+   void
+===========================================================================*/
+static void __exit GobiUSBNetModExit( void )
+{
+   usb_deregister( &GobiNet );
+
+   class_destroy( gpClass );
+}
+module_exit( GobiUSBNetModExit );
+
+MODULE_VERSION( DRIVER_VERSION );
+MODULE_AUTHOR( DRIVER_AUTHOR );
+MODULE_DESCRIPTION( DRIVER_DESC );
+MODULE_LICENSE("Dual BSD/GPL");
+ 
+#ifdef bool
+#undef bool
+#endif
+
+module_param( Gobi_debug, int, S_IRUGO | S_IWUSR );
+MODULE_PARM_DESC( Gobi_debug, "Debuging enabled or not" );
+
+module_param( interruptible, int, S_IRUGO | S_IWUSR );
+MODULE_PARM_DESC( interruptible, "Listen for and return on user interrupt" );
+module_param( txQueueLength, int, S_IRUGO | S_IWUSR );
+MODULE_PARM_DESC( txQueueLength, 
+                  "Number of IP packets which may be queued up for transmit" );
+
diff -Naur a/drivers/net/usb/Kconfig b/drivers/net/usb/Kconfig
--- a/drivers/net/usb/Kconfig	2018-08-16 00:13:02.000000000 +0800
+++ b/drivers/net/usb/Kconfig	2020-01-15 10:15:46.363337051 +0800
@@ -538,6 +538,12 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called qmi_wwan.
 
+
+# Nexsec add for GobiNet
+config USB_NET_GOBINET
+        tristate "GOBINET driver for Qualcomm MSM based 3G and LTE modems"
+        depends on USB_USBNET
+
 config USB_HSO
 	tristate "Option USB High Speed Mobile Devices"
 	depends on USB && RFKILL && TTY
diff -Naur a/drivers/net/usb/Makefile b/drivers/net/usb/Makefile
--- a/drivers/net/usb/Makefile	2018-08-16 00:13:02.000000000 +0800
+++ b/drivers/net/usb/Makefile	2020-01-15 10:17:34.125596817 +0800
@@ -40,3 +40,11 @@
 obj-$(CONFIG_USB_NET_QMI_WWAN)	+= qmi_wwan.o
 obj-$(CONFIG_USB_NET_CDC_MBIM)	+= cdc_mbim.o
 obj-$(CONFIG_USB_NET_CH9200)	+= ch9200.o
+
+# Nexsec add GobiNet driver for FIBOCOM FG150
+obj-$(CONFIG_USB_NET_GOBINET)  += GobiNet.o
+GobiNet-objs := GobiUSBNet.o QMIDevice.o QMI.o
+
+
+
+
diff -Naur a/drivers/net/usb/QMI.c b/drivers/net/usb/QMI.c
--- a/drivers/net/usb/QMI.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/net/usb/QMI.c	2020-01-15 10:21:50.588634008 +0800
@@ -0,0 +1,1750 @@
+/*===========================================================================
+FILE:
+   QMI.c
+
+DESCRIPTION:
+   Qualcomm QMI driver code
+   
+FUNCTIONS:
+   Generic QMUX functions
+      ParseQMUX
+      FillQMUX
+   
+   Generic QMI functions
+      GetTLV
+      ValidQMIMessage
+      GetQMIMessageID
+
+   Fill Buffers with QMI requests
+      QMICTLGetClientIDReq
+      QMICTLReleaseClientIDReq
+      QMICTLReadyReq
+      QMIWDSSetEventReportReq
+      QMIWDSGetPKGSRVCStatusReq
+      QMIDMSGetMEIDReq
+      QMIWDASetDataFormatReq
+      QMICTLSetDataFormatReq
+      QMICTLSyncReq
+      
+   Parse data from QMI responses
+      QMICTLGetClientIDResp
+      QMICTLReleaseClientIDResp
+      QMIWDSEventResp
+      QMIDMSGetMEIDResp
+      QMIWDASetDataFormatResp
+      QMICTLSyncResp
+
+Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of Code Aurora Forum nor
+      the names of its contributors may be used to endorse or promote
+      products derived from this software without specific prior written
+      permission.
+
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+===========================================================================*/
+
+//---------------------------------------------------------------------------
+// Include Files
+//---------------------------------------------------------------------------
+#include <asm/unaligned.h>
+#include <linux/kernel.h>
+#include "Structs.h"
+#include "QMI.h"
+
+#define RMNET_FG150 1
+#define DATA_MODE_RP 1
+#define RMNET_FG150_90DB 0
+
+static int interfaceNumber = 0;
+
+int GetDeviceInterfaceNumber(void)
+{
+   return interfaceNumber;
+}
+
+void SetDeviceInterfaceNumber(int nInterfaceNulber)
+{
+   interfaceNumber = nInterfaceNulber;
+}
+
+void PrintQMIHex(
+   void *      pBuffer,
+   u16         bufSize )
+{
+   char * pPrintBuf;
+   u16 pos;
+   int status;
+   
+   if (Gobi_debug != 1)
+   {
+       return;
+   }
+
+   pPrintBuf = kmalloc( bufSize * 3 + 1, GFP_ATOMIC );
+   if (pPrintBuf == NULL)
+   {
+      DBG( "Unable to allocate buffer\n" );
+      return;
+   }
+   memset( pPrintBuf, 0 , bufSize * 3 + 1 );
+   
+   for (pos = 0; pos < bufSize; pos++)
+   {
+      status = snprintf( (pPrintBuf + (pos * 3)), 
+                         4, 
+                         "%02X ", 
+                         *(u8 *)(pBuffer + pos) );
+      if (status != 3)
+      {
+         DBG( "snprintf error %d\n", status );
+         kfree( pPrintBuf );
+         return;
+      }
+   }
+   
+   DBG( "   : %s\n", pPrintBuf );
+
+   kfree( pPrintBuf );
+   pPrintBuf = NULL;
+   return;   
+}
+/*=========================================================================*/
+// Get sizes of buffers needed by QMI requests
+/*=========================================================================*/
+/*===========================================================================
+METHOD:
+   QMUXHeaderSize (Public Method)
+
+DESCRIPTION:
+   Get size of buffer needed for QMUX
+ 
+RETURN VALUE:
+   u16 - size of buffer
+===========================================================================*/
+u16 QMUXHeaderSize( void )
+{
+   return sizeof( sQMUX );
+}
+
+/*===========================================================================
+METHOD:
+   QMICTLGetClientIDReqSize (Public Method)
+
+DESCRIPTION:
+   Get size of buffer needed for QMUX + QMICTLGetClientIDReq
+ 
+RETURN VALUE:
+   u16 - size of buffer
+===========================================================================*/
+u16 QMICTLGetClientIDReqSize( void )
+{
+   return sizeof( sQMUX ) + 10;
+}
+
+/*===========================================================================
+METHOD:
+   QMICTLReleaseClientIDReqSize (Public Method)
+
+DESCRIPTION:
+   Get size of buffer needed for QMUX + QMICTLReleaseClientIDReq
+ 
+RETURN VALUE:
+   u16 - size of header
+===========================================================================*/
+u16 QMICTLReleaseClientIDReqSize( void )
+{
+   return sizeof( sQMUX ) + 11;
+}
+
+/*===========================================================================
+METHOD:
+   QMICTLReadyReqSize (Public Method)
+
+DESCRIPTION:
+   Get size of buffer needed for QMUX + QMICTLReadyReq
+ 
+RETURN VALUE:
+   u16 - size of buffer
+===========================================================================*/
+u16 QMICTLReadyReqSize( void )
+{
+   return sizeof( sQMUX ) + 6;
+}
+
+/*===========================================================================
+METHOD:
+   QMIWDSSetEventReportReqSize (Public Method)
+
+DESCRIPTION:
+   Get size of buffer needed for QMUX + QMIWDSSetEventReportReq
+ 
+RETURN VALUE:
+   u16 - size of buffer
+===========================================================================*/
+u16 QMIWDSSetEventReportReqSize( void )
+{
+   return sizeof( sQMUX ) + 15;
+}
+
+/*===========================================================================
+METHOD:
+   QMIWDSGetPKGSRVCStatusReqSize (Public Method)
+
+DESCRIPTION:
+   Get size of buffer needed for QMUX + QMIWDSGetPKGSRVCStatusReq
+ 
+RETURN VALUE:
+   u16 - size of buffer
+===========================================================================*/
+u16 QMIWDSGetPKGSRVCStatusReqSize( void )
+{
+   return sizeof( sQMUX ) + 7;
+}
+
+/*===========================================================================
+METHOD:
+   QMIDMSGetMEIDReqSize (Public Method)
+
+DESCRIPTION:
+   Get size of buffer needed for QMUX + QMIDMSGetMEIDReq
+ 
+RETURN VALUE:
+   u16 - size of buffer
+===========================================================================*/
+u16 QMIDMSGetMEIDReqSize( void )
+{
+   return sizeof( sQMUX ) + 7;
+}
+
+/*===========================================================================
+METHOD:
+   QMIWDASetDataFormatReqSize (Public Method)
+
+DESCRIPTION:
+   Get size of buffer needed for QMUX + QMIWDASetDataFormatReq
+
+RETURN VALUE:
+   u16 - size of buffer
+===========================================================================*/
+u16 QMIWDASetDataFormatReqSize( void )
+{
+#ifdef RMNET_FG150
+   return sizeof( sQMUX ) + 77;
+#else
+   return sizeof( sQMUX ) + 25;
+#endif
+}
+
+/*===========================================================================
+METHOD:
+   QMICTLSetDataFormatReqSize (Public Method)
+
+DESCRIPTION:
+   Get size of buffer needed for QMUX + QMICTLSetDataFormatReq
+ 
+RETURN VALUE:
+   u16 - size of buffer
+===========================================================================*/
+u16  QMICTLSetDataFormatReqSize( void )
+{
+   return sizeof( sQMUX ) + 15; 
+}
+
+/*===========================================================================
+METHOD:
+   QMICTLSyncReqSize (Public Method)
+
+DESCRIPTION:
+   Get size of buffer needed for QMUX + QMICTLSyncReq
+ 
+RETURN VALUE:
+   u16 - size of buffer
+===========================================================================*/
+u16  QMICTLSyncReqSize( void )
+{
+   return sizeof( sQMUX ) + 6; 
+}
+
+/*=========================================================================*/
+// Generic QMUX functions
+/*=========================================================================*/
+
+/*===========================================================================
+METHOD:
+   ParseQMUX (Public Method)
+
+DESCRIPTION:
+   Remove QMUX headers from a buffer
+
+PARAMETERS
+   pClientID       [ O ] - On success, will point to Client ID
+   pBuffer         [ I ] - Full Message passed in
+   buffSize        [ I ] - Size of pBuffer
+
+RETURN VALUE:
+   int - Positive for size of QMUX header
+         Negative errno for error
+===========================================================================*/
+int ParseQMUX(
+   u16 *    pClientID,
+   void *   pBuffer,
+   u16      buffSize )
+{
+   sQMUX * pQMUXHeader;
+   
+   if (pBuffer == 0 || buffSize < 12)
+   {
+      return -ENOMEM;
+   }
+
+   // QMUX Header
+   pQMUXHeader = (sQMUX *)pBuffer;
+
+   if (pQMUXHeader->mTF != 1
+   ||  le16_to_cpu(get_unaligned(&pQMUXHeader->mLength)) != buffSize - 1
+   ||  pQMUXHeader->mCtrlFlag != 0x80 )
+   {
+      return -EINVAL;
+   }
+
+   // Client ID   
+   *pClientID = (pQMUXHeader->mQMIClientID << 8) + pQMUXHeader->mQMIService;
+   
+   return sizeof( sQMUX );
+}
+
+/*===========================================================================
+METHOD:
+   FillQMUX (Public Method)
+
+DESCRIPTION:
+   Fill buffer with QMUX headers
+
+PARAMETERS
+   clientID        [ I ] - Client ID
+   pBuffer         [ O ] - Buffer to be filled
+   buffSize        [ I ] - Size of pBuffer (must be at least 6)
+
+RETURN VALUE:
+   int - 0 for success
+         Negative errno for error
+===========================================================================*/
+int FillQMUX(
+   u16      clientID,
+   void *   pBuffer,
+   u16      buffSize )
+{
+   sQMUX * pQMUXHeader;
+
+   if (pBuffer == 0 ||  buffSize < sizeof( sQMUX ))
+   {
+      return -ENOMEM;
+   }
+
+   // QMUX Header
+   pQMUXHeader = (sQMUX *)pBuffer;
+
+   pQMUXHeader->mTF = 1;
+   put_unaligned(cpu_to_le16(buffSize - 1), &pQMUXHeader->mLength);
+   DBG("pQMUXHeader->mLength = 0x%x, buffSize - 1 = 0x%x\n",pQMUXHeader->mLength, buffSize - 1);
+   pQMUXHeader->mCtrlFlag = 0;
+
+   // Service and Client ID   
+   pQMUXHeader->mQMIService = clientID & 0xff;
+   pQMUXHeader->mQMIClientID = clientID >> 8;
+
+   return 0;
+}
+
+/*=========================================================================*/
+// Generic QMI functions
+/*=========================================================================*/
+
+/*===========================================================================
+METHOD:
+   GetTLV (Public Method)
+
+DESCRIPTION:
+   Get data buffer of a specified TLV from a QMI message
+
+   QMI Message shall NOT include SDU
+   
+PARAMETERS
+   pQMIMessage    [ I ] - QMI Message buffer
+   messageLen     [ I ] - Size of QMI Message buffer
+   type           [ I ] - Desired Type
+   pOutDataBuf    [ O ] - Buffer to be filled with TLV
+   messageLen     [ I ] - Size of QMI Message buffer
+
+RETURN VALUE:
+   u16 - Size of TLV for success
+         Negative errno for error
+===========================================================================*/
+int GetTLV(
+   void *   pQMIMessage,
+   u16      messageLen,
+   u8       type,
+   void *   pOutDataBuf,
+   u16      bufferLen )
+{
+   u16 pos;
+   u16 tlvSize = 0;
+   u16 cpyCount;
+   
+   if (pQMIMessage == 0 || pOutDataBuf == 0)
+   {
+      return -ENOMEM;
+   }   
+   
+   for (pos = 4; 
+        pos + 3 < messageLen; 
+        pos += tlvSize + 3)
+   {
+      tlvSize = le16_to_cpu( get_unaligned(((u16 *)(pQMIMessage + pos + 1) )) );
+      if (*(u8 *)(pQMIMessage + pos) == type)
+      {
+         if (bufferLen < tlvSize)
+         {
+            return -ENOMEM;
+         }
+                
+         for (cpyCount = 0; cpyCount < tlvSize; cpyCount++)
+         {
+            *((char*)(pOutDataBuf + cpyCount)) = *((char*)(pQMIMessage + pos + 3 + cpyCount));
+         }
+         
+         return tlvSize;
+      }
+   }
+   
+   return -ENOMSG;
+}
+
+/*===========================================================================
+METHOD:
+   ValidQMIMessage (Public Method)
+
+DESCRIPTION:
+   Check mandatory TLV in a QMI message
+
+   QMI Message shall NOT include SDU
+
+PARAMETERS
+   pQMIMessage    [ I ] - QMI Message buffer
+   messageLen     [ I ] - Size of QMI Message buffer
+
+RETURN VALUE:
+   int - 0 for success (no error)
+         Negative errno for error
+         Positive for QMI error code
+===========================================================================*/
+int ValidQMIMessage(
+   void *   pQMIMessage,
+   u16      messageLen )
+{
+   char mandTLV[4];
+
+   if (GetTLV( pQMIMessage, messageLen, 2, &mandTLV[0], 4 ) == 4)
+   {
+      // Found TLV
+      if (*(u16 *)&mandTLV[0] != 0)
+      {
+         return le16_to_cpu( get_unaligned(&mandTLV[2]) );
+      }
+      else
+      {
+         return 0;
+      }
+   }
+   else
+   {
+      return -ENOMSG;
+   }
+}      
+
+/*===========================================================================
+METHOD:
+   GetQMIMessageID (Public Method)
+
+DESCRIPTION:
+   Get the message ID of a QMI message
+   
+   QMI Message shall NOT include SDU
+
+PARAMETERS
+   pQMIMessage    [ I ] - QMI Message buffer
+   messageLen     [ I ] - Size of QMI Message buffer
+
+RETURN VALUE:
+   int - Positive for message ID
+         Negative errno for error
+===========================================================================*/
+int GetQMIMessageID(
+   void *   pQMIMessage,
+   u16      messageLen )
+{
+   if (messageLen < 2)
+   {
+      return -ENODATA;
+   }
+   else
+   {
+      return le16_to_cpu( get_unaligned((u16 *)pQMIMessage) );
+   }
+}
+
+/*=========================================================================*/
+// Fill Buffers with QMI requests
+/*=========================================================================*/
+
+/*===========================================================================
+METHOD:
+   QMICTLGetClientIDReq (Public Method)
+
+DESCRIPTION:
+   Fill buffer with QMI CTL Get Client ID Request
+
+PARAMETERS
+   pBuffer         [ 0 ] - Buffer to be filled
+   buffSize        [ I ] - Size of pBuffer
+   transactionID   [ I ] - Transaction ID
+   serviceType     [ I ] - Service type requested
+
+RETURN VALUE:
+   int - Positive for resulting size of pBuffer
+         Negative errno for error
+===========================================================================*/
+int QMICTLGetClientIDReq(
+   void *   pBuffer,
+   u16      buffSize,
+   u8       transactionID,
+   u8       serviceType )
+{
+   if (pBuffer == 0 || buffSize < QMICTLGetClientIDReqSize() )
+   {
+      return -ENOMEM;
+   }
+
+   // QMI CTL GET CLIENT ID
+   // Request
+   *(u8 *)(pBuffer + sizeof( sQMUX ))= 0x00;
+   // Transaction ID
+   *(u8 *)(pBuffer + sizeof( sQMUX ) + 1) = transactionID;
+   // Message ID
+   put_unaligned(cpu_to_le16(0x0022), (u16 *)(pBuffer + sizeof( sQMUX ) + 2));
+   // Size of TLV's
+   put_unaligned(cpu_to_le16(0x0004), (u16 *)(pBuffer + sizeof( sQMUX ) + 4));
+      // QMI Service Type
+      *(u8 *)(pBuffer + sizeof( sQMUX ) + 6)  = 0x01;
+      // Size
+   put_unaligned(cpu_to_le16(0x0001), (u16 *)(pBuffer + sizeof( sQMUX ) + 7));
+      // QMI svc type
+      *(u8 *)(pBuffer + sizeof( sQMUX ) + 9)  = serviceType;
+
+   // success
+   return sizeof( sQMUX ) + 10;
+}
+
+/*===========================================================================
+METHOD:
+   QMICTLReleaseClientIDReq (Public Method)
+
+DESCRIPTION:
+   Fill buffer with QMI CTL Release Client ID Request
+
+PARAMETERS
+   pBuffer         [ 0 ] - Buffer to be filled
+   buffSize        [ I ] - Size of pBuffer
+   transactionID   [ I ] - Transaction ID
+   clientID        [ I ] - Service type requested
+
+RETURN VALUE:
+   int - Positive for resulting size of pBuffer
+         Negative errno for error
+===========================================================================*/
+int QMICTLReleaseClientIDReq(
+   void *   pBuffer,
+   u16      buffSize,
+   u8       transactionID,
+   u16      clientID )
+{
+   if (pBuffer == 0 || buffSize < QMICTLReleaseClientIDReqSize() )
+   {
+      return -ENOMEM;
+   }
+
+   DBG(  "buffSize: 0x%x, transactionID: 0x%x, clientID: 0x%x,\n",
+         buffSize, transactionID, clientID );
+
+   // QMI CTL RELEASE CLIENT ID REQ
+   // Request
+   *(u8 *)(pBuffer + sizeof( sQMUX ))  = 0x00;
+   // Transaction ID
+   *(u8 *)(pBuffer + sizeof( sQMUX ) + 1 ) = transactionID;
+   // Message ID
+   put_unaligned( cpu_to_le16(0x0023), (u16 *)(pBuffer + sizeof( sQMUX ) + 2) );
+   // Size of TLV's
+   put_unaligned( cpu_to_le16(0x0005), (u16 *)(pBuffer + sizeof( sQMUX ) + 4) );
+      // Release client ID
+      *(u8 *)(pBuffer + sizeof( sQMUX ) + 6)  = 0x01;
+      // Size
+   put_unaligned( cpu_to_le16(0x0002), (u16 *)(pBuffer + sizeof( sQMUX ) + 7));
+      // QMI svs type / Client ID
+   put_unaligned(cpu_to_le16(clientID), (u16 *)(pBuffer + sizeof( sQMUX ) + 9));
+      
+   // success
+   return sizeof( sQMUX ) + 11;
+}
+
+/*===========================================================================
+METHOD:
+   QMICTLReadyReq (Public Method)
+
+DESCRIPTION:
+   Fill buffer with QMI CTL Get Version Info Request
+
+PARAMETERS
+   pBuffer         [ 0 ] - Buffer to be filled
+   buffSize        [ I ] - Size of pBuffer
+   transactionID   [ I ] - Transaction ID
+
+RETURN VALUE:
+   int - Positive for resulting size of pBuffer
+         Negative errno for error
+===========================================================================*/
+int QMICTLReadyReq(
+   void *   pBuffer,
+   u16      buffSize,
+   u8       transactionID )
+{
+   if (pBuffer == 0 || buffSize < QMICTLReadyReqSize() )
+   {
+      return -ENOMEM;
+   }
+
+   DBG("buffSize: 0x%x, transactionID: 0x%x\n", buffSize, transactionID);
+
+   // QMI CTL GET VERSION INFO REQ
+   // Request
+   *(u8 *)(pBuffer + sizeof( sQMUX ))  = 0x00;
+   // Transaction ID
+   *(u8 *)(pBuffer + sizeof( sQMUX ) + 1) = transactionID;
+   // Message ID
+   put_unaligned( cpu_to_le16(0x0021), (u16 *)(pBuffer + sizeof( sQMUX ) + 2) );
+   // Size of TLV's
+   put_unaligned( cpu_to_le16(0x0000), (u16 *)(pBuffer + sizeof( sQMUX ) + 4) );
+
+   // success
+   return sizeof( sQMUX ) + 6;
+}
+
+/*===========================================================================
+METHOD:
+   QMIWDSSetEventReportReq (Public Method)
+
+DESCRIPTION:
+   Fill buffer with QMI WDS Set Event Report Request
+
+PARAMETERS
+   pBuffer         [ 0 ] - Buffer to be filled
+   buffSize        [ I ] - Size of pBuffer
+   transactionID   [ I ] - Transaction ID
+
+RETURN VALUE:
+   int - Positive for resulting size of pBuffer
+         Negative errno for error
+===========================================================================*/
+int QMIWDSSetEventReportReq(
+   void *   pBuffer,
+   u16      buffSize,
+   u16      transactionID )
+{
+   if (pBuffer == 0 || buffSize < QMIWDSSetEventReportReqSize() )
+   {
+      return -ENOMEM;
+   }
+
+   // QMI WDS SET EVENT REPORT REQ
+   // Request
+   *(u8 *)(pBuffer + sizeof( sQMUX ))  = 0x00;
+   // Transaction ID
+   put_unaligned( cpu_to_le16(transactionID), (u16 *)(pBuffer + sizeof( sQMUX ) + 1));
+   // Message ID
+   put_unaligned( cpu_to_le16(0x0001), (u16 *)(pBuffer + sizeof( sQMUX ) + 3));
+   // Size of TLV's
+   put_unaligned(cpu_to_le16(0x0008), (u16 *)(pBuffer + sizeof( sQMUX ) + 5));
+      // Report channel rate TLV
+      *(u8 *)(pBuffer + sizeof( sQMUX ) + 7)  = 0x11;
+      // Size
+   put_unaligned( cpu_to_le16(0x0005), (u16 *)(pBuffer + sizeof( sQMUX ) + 8));
+      // Stats period
+      *(u8 *)(pBuffer + sizeof( sQMUX ) + 10)  = 0x01;
+      // Stats mask
+   put_unaligned( cpu_to_le32(0x000000ff), (u32 *)(pBuffer + sizeof( sQMUX ) + 11) );
+
+   // success
+   return sizeof( sQMUX ) + 15;
+}
+
+/*===========================================================================
+METHOD:
+   QMIWDSGetPKGSRVCStatusReq (Public Method)
+
+DESCRIPTION:
+   Fill buffer with QMI WDS Get PKG SRVC Status Request
+
+PARAMETERS
+   pBuffer         [ 0 ] - Buffer to be filled
+   buffSize        [ I ] - Size of pBuffer
+   transactionID   [ I ] - Transaction ID
+
+RETURN VALUE:
+   int - Positive for resulting size of pBuffer
+         Negative errno for error
+===========================================================================*/
+int QMIWDSGetPKGSRVCStatusReq(
+   void *   pBuffer,
+   u16      buffSize,
+   u16      transactionID )
+{
+   if (pBuffer == 0 || buffSize < QMIWDSGetPKGSRVCStatusReqSize() )
+   {
+      return -ENOMEM;
+   }
+
+   // QMI WDS Get PKG SRVC Status REQ
+   // Request
+   *(u8 *)(pBuffer + sizeof( sQMUX ))  = 0x00;
+   // Transaction ID
+   put_unaligned(cpu_to_le16(transactionID), (u16 *)(pBuffer + sizeof( sQMUX ) + 1));
+   // Message ID
+   put_unaligned(cpu_to_le16(0x0022), (u16 *)(pBuffer + sizeof( sQMUX ) + 3));
+   // Size of TLV's
+   put_unaligned(cpu_to_le16(0x0000), (u16 *)(pBuffer + sizeof( sQMUX ) + 5));
+
+   // success
+   return sizeof( sQMUX ) + 7;
+}
+
+/*===========================================================================
+METHOD:
+   QMIDMSGetMEIDReq (Public Method)
+
+DESCRIPTION:
+   Fill buffer with QMI DMS Get Serial Numbers Request
+
+PARAMETERS
+   pBuffer         [ 0 ] - Buffer to be filled
+   buffSize        [ I ] - Size of pBuffer
+   transactionID   [ I ] - Transaction ID
+
+RETURN VALUE:
+   int - Positive for resulting size of pBuffer
+         Negative errno for error
+===========================================================================*/
+int QMIDMSGetMEIDReq(
+   void *   pBuffer,
+   u16      buffSize,
+   u16      transactionID )
+{
+   if (pBuffer == 0 || buffSize < QMIDMSGetMEIDReqSize() )
+   {
+      return -ENOMEM;
+   }
+
+   // QMI DMS GET SERIAL NUMBERS REQ
+   // Request
+   *(u8 *)(pBuffer + sizeof( sQMUX ))  = 0x00;
+   // Transaction ID
+   put_unaligned( cpu_to_le16(transactionID), (u16 *)(pBuffer + sizeof( sQMUX ) + 1) );
+   // Message ID
+   put_unaligned( cpu_to_le16(0x0025), (u16 *)(pBuffer + sizeof( sQMUX ) + 3) );
+   // Size of TLV's
+   put_unaligned( cpu_to_le16(0x0000), (u16 *)(pBuffer + sizeof( sQMUX ) + 5));
+
+   // success
+   return sizeof( sQMUX ) + 7;
+}
+
+/*===========================================================================
+METHOD:
+   QMIWDASetDataFormatReq (Public Method)
+
+DESCRIPTION:
+   Fill buffer with QMI WDA Set Data Format Request
+
+PARAMETERS
+   pBuffer         [ 0 ] - Buffer to be filled
+   buffSize        [ I ] - Size of pBuffer
+   transactionID   [ I ] - Transaction ID
+
+RETURN VALUE:
+   int - Positive for resulting size of pBuffer
+         Negative errno for error
+===========================================================================*/
+int QMIWDASetDataFormatReq(
+   void *   pBuffer,
+   u16      buffSize,
+   u16      transactionID )
+{
+   int intf_id;
+
+   if (pBuffer == 0 || buffSize < QMIWDASetDataFormatReqSize() )
+   {
+      return -ENOMEM;
+   }
+
+   // QMI WDA SET DATA FORMAT REQ
+   // Request
+   *(u8 *)(pBuffer + sizeof( sQMUX ))  = 0x00;
+
+   // Transaction ID
+   put_unaligned( cpu_to_le16(transactionID), (u16 *)(pBuffer + sizeof( sQMUX ) + 1) );
+
+   // Message ID
+   put_unaligned( cpu_to_le16(0x0020), (u16 *)(pBuffer + sizeof( sQMUX ) + 3) );
+
+   // Size of TLV's
+#ifdef RMNET_FG150
+   put_unaligned( cpu_to_le16(0x0040), (u16 *)(pBuffer + sizeof( sQMUX ) + 5));
+#else
+   put_unaligned( cpu_to_le16(0x0012), (u16 *)(pBuffer + sizeof( sQMUX ) + 5));
+#endif
+   /* TLVType QOS Data Format 1 byte  */
+   *(u8 *)(pBuffer + sizeof( sQMUX ) +  7) = 0x10; // type data format
+
+   /* TLVLength  2 bytes - see spec */
+   put_unaligned( cpu_to_le16(0x0001), (u16 *)(pBuffer + sizeof( sQMUX ) + 8)); 
+
+   /* DataFormat: 0-default; 1-QoS hdr present 2 bytes */
+#ifdef QOS_MODE
+   *(u8 *)(pBuffer + sizeof( sQMUX ) + 10) = 1; /* QOS header */
+#else
+   *(u8 *)(pBuffer + sizeof( sQMUX ) + 10) = 0; /* no-QOS header */
+#endif
+
+   /* TLVType Link-Layer Protocol  (Optional) 1 byte */
+   *(u8 *)(pBuffer + sizeof( sQMUX ) + 11) = 0x11;
+
+   /* TLVLength 2 bytes */
+   put_unaligned( cpu_to_le16(0x0004), (u16 *)(pBuffer + sizeof( sQMUX ) + 12));
+
+   /* LinkProt: 0x1 - ETH; 0x2 - rawIP  4 bytes */
+#ifdef DATA_MODE_RP
+   /* Set RawIP mode */
+   put_unaligned( cpu_to_le32(0x00000002), (u32 *)(pBuffer + sizeof( sQMUX ) + 14));
+   DBG("Request RawIP Data Format\n");
+#else
+   /* Set Ethernet  mode */
+   put_unaligned( cpu_to_le32(0x00000001), (u32 *)(pBuffer + sizeof( sQMUX ) + 14));
+   DBG("Request Ethernet Data Format\n");
+#endif
+
+#ifdef RMNET_FG150
+   /* Set Underlying Link Layer Protocol */
+   *(u8 *)(pBuffer + sizeof( sQMUX ) + 18) = 0x12;
+
+   /* TLVLength 2 bytes */
+   put_unaligned( cpu_to_le16(0x0004), (u16 *)(pBuffer + sizeof( sQMUX ) + 19));
+
+   /* TLV Data */
+   put_unaligned( cpu_to_le32(0x00000000), (u32 *)(pBuffer + sizeof( sQMUX ) + 21));
+
+   *(u8 *)(pBuffer + sizeof( sQMUX ) + 25) = 0x13;
+
+   /* TLVLength 2 bytes */
+   put_unaligned( cpu_to_le16(0x0004), (u16 *)(pBuffer + sizeof( sQMUX ) + 26));
+
+   /* TLV Data */
+   put_unaligned( cpu_to_le32(0x00000000), (u32 *)(pBuffer + sizeof( sQMUX ) + 28));
+
+   /* Set Downlink Data Aggregation Max Datagrams type */
+   *(u8 *)(pBuffer + sizeof( sQMUX ) + 32) = 0x15;
+
+   /* TLVLength 2 bytes */
+   put_unaligned( cpu_to_le16(0x0004), (u16 *)(pBuffer + sizeof( sQMUX ) + 33));
+
+   /* TLV Data */
+   put_unaligned( cpu_to_le32(0x00000020), (u32 *)(pBuffer + sizeof( sQMUX ) + 35));
+
+   /* Set Downlink Data Aggregation Max Size type */
+   *(u8 *)(pBuffer + sizeof( sQMUX ) + 39) = 0x16;
+
+   /* TLVLength 2 bytes */
+   put_unaligned( cpu_to_le16(0x0004), (u16 *)(pBuffer + sizeof( sQMUX ) + 40));
+
+   /* TLV Data */
+   put_unaligned( cpu_to_le32(0x00008000), (u32 *)(pBuffer + sizeof( sQMUX ) + 42));
+
+   /* Set Peripheral End Point ID type */
+   *(u8 *)(pBuffer + sizeof( sQMUX ) + 46) = 0x17;
+
+   /* TLVLength 2 bytes */
+   put_unaligned( cpu_to_le16(0x0008), (u16 *)(pBuffer + sizeof( sQMUX ) + 47));
+
+   /* TLV Data */
+   put_unaligned( cpu_to_le32(0x00000002), (u32 *)(pBuffer + sizeof( sQMUX ) + 49));
+
+   intf_id = GetDeviceInterfaceNumber();
+   put_unaligned( cpu_to_le32(intf_id), (u32 *)(pBuffer + sizeof( sQMUX ) + 53));
+   PrintQMIHex((pBuffer + sizeof( sQMUX ) + 53),4);
+#if 0
+#ifdef RMNET_FG150_90DB
+   put_unaligned( cpu_to_le32(0x00000002), (u32 *)(pBuffer + sizeof( sQMUX ) + 53)); //for 0x05c6/90db
+#else
+   put_unaligned( cpu_to_le32(0x00000004), (u32 *)(pBuffer + sizeof( sQMUX ) + 53));
+#endif   
+#endif
+
+   *(u8 *)(pBuffer + sizeof( sQMUX ) + 57) = 0x1B;
+
+   /* TLVLength 2 bytes */
+   put_unaligned( cpu_to_le16(0x0004), (u16 *)(pBuffer + sizeof( sQMUX ) + 58));
+
+   /* TLV Data */
+   put_unaligned( cpu_to_le32(0x00000015), (u32 *)(pBuffer + sizeof( sQMUX ) + 60));
+
+   *(u8 *)(pBuffer + sizeof( sQMUX ) + 64) = 0x1C;
+
+   /* TLVLength 2 bytes */
+   put_unaligned( cpu_to_le16(0x0004), (u16 *)(pBuffer + sizeof( sQMUX ) + 65));
+
+   /* TLV Data */
+   put_unaligned( cpu_to_le32(0x00008000), (u32 *)(pBuffer + sizeof( sQMUX ) + 67));
+#else
+   /* TLVType Uplink Data Aggression Protocol - 1 byte */
+   *(u8 *)(pBuffer + sizeof( sQMUX ) + 18) = 0x13;
+
+   /* TLVLength 2 bytes */
+   put_unaligned( cpu_to_le16(0x0004), (u16 *)(pBuffer + sizeof( sQMUX ) + 19));
+
+   /* TLV Data */
+   put_unaligned( cpu_to_le32(0x00000000), (u32 *)(pBuffer + sizeof( sQMUX ) + 21));
+#endif
+   // success
+   return QMIWDASetDataFormatReqSize();
+}
+
+
+
+/*===========================================================================
+METHOD:
+   QMICTLSetDataFormatReq (Public Method)
+
+DESCRIPTION:
+   Fill buffer with QMI CTL Set Data Format Request
+
+PARAMETERS
+   pBuffer         [ 0 ] - Buffer to be filled
+   buffSize        [ I ] - Size of pBuffer
+   transactionID   [ I ] - Transaction ID
+
+RETURN VALUE:
+   int - Positive for resulting size of pBuffer
+         Negative errno for error
+===========================================================================*/
+int QMICTLSetDataFormatReq(
+   void *   pBuffer,
+   u16      buffSize,
+   u8       transactionID )
+{
+   if (pBuffer == 0 || buffSize < QMICTLSetDataFormatReqSize() )
+   {
+      return -ENOMEM;
+   }
+
+   /* QMI CTL Set Data Format Request */
+   /* Request */
+   *(u8 *)(pBuffer + sizeof( sQMUX ))  = 0x00; // QMICTL_FLAG_REQUEST
+   
+   /* Transaction ID 1 byte */
+   *(u8 *)(pBuffer + sizeof( sQMUX ) + 1) = transactionID; /* 1 byte as in spec */
+
+   /* QMICTLType  2 bytes */
+   put_unaligned( cpu_to_le16(0x0026), (u16 *)(pBuffer + sizeof( sQMUX ) + 2));
+
+   /* Length  2 bytes  of 2 TLVs  each - see spec */
+   put_unaligned( cpu_to_le16(0x0009), (u16 *)(pBuffer + sizeof( sQMUX ) + 4));
+
+   /* TLVType Data Format (Mandatory)  1 byte  */
+   *(u8 *)(pBuffer + sizeof( sQMUX ) +  6) = 0x01; // type data format
+
+   /* TLVLength  2 bytes - see spec */
+   put_unaligned( cpu_to_le16(0x0001), (u16 *)(pBuffer + sizeof( sQMUX ) + 7)); 
+
+   /* DataFormat: 0-default; 1-QoS hdr present 2 bytes */
+#ifdef QOS_MODE
+   *(u8 *)(pBuffer + sizeof( sQMUX ) + 9) = 1; /* QOS header */
+#else
+   *(u8 *)(pBuffer + sizeof( sQMUX ) + 9) = 0; /* no-QOS header */
+#endif
+
+    /* TLVType Link-Layer Protocol  (Optional) 1 byte */
+    *(u8 *)(pBuffer + sizeof( sQMUX ) + 10) = TLV_TYPE_LINK_PROTO;
+
+    /* TLVLength 2 bytes */
+    put_unaligned( cpu_to_le16(0x0002), (u16 *)(pBuffer + sizeof( sQMUX ) + 11));
+
+   /* LinkProt: 0x1 - ETH; 0x2 - rawIP  2 bytes */
+#ifdef DATA_MODE_RP
+   /* Set RawIP mode */
+   put_unaligned( cpu_to_le16(0x0002), (u16 *)(pBuffer + sizeof( sQMUX ) + 13));
+   DBG("Request RawIP Data Format\n");
+#else
+   /* Set Ethernet  mode */
+   put_unaligned( cpu_to_le16(0x0001), (u16 *)(pBuffer + sizeof( sQMUX ) + 13));
+   DBG("Request Ethernet Data Format\n");
+#endif
+
+   /* success */
+   return sizeof( sQMUX ) + 15;
+
+}
+
+
+
+/*===========================================================================
+METHOD:
+   QMIWDSBindMuxDataPortReqSize (Public Method)
+
+DESCRIPTION:
+   Get size of buffer needed for QMUX + QMIWDSBindMuxDataPortReq
+ 
+RETURN VALUE:
+   u16 - size of buffer
+===========================================================================*/
+u16 QMIWDSBindMuxDataPortReqSize( void )
+{
+   return sizeof( sQMUX ) + 29;
+}
+
+
+
+/*===========================================================================
+METHOD:
+   QMIWDSBindMuxDataPortReq (Public Method)
+
+DESCRIPTION:
+   Fill buffer with QMI WDS Bind Mux Data Port Request
+
+PARAMETERS
+   pBuffer         [ 0 ] - Buffer to be filled
+   buffSize        [ I ] - Size of pBuffer
+   transactionID   [ I ] - Transaction ID
+
+RETURN VALUE:
+   int - Positive for resulting size of pBuffer
+         Negative errno for error
+===========================================================================*/
+int QMIWDSBindMuxDataPortReq(
+   u16 platid,
+   void *   pBuffer,
+   u16      buffSize,
+   u16      transactionID )
+{
+   int iface_id;
+   DBG("#### QMIWDSBindMuxDataPortReq : platid = %d \n",platid);
+   if (pBuffer == 0 || buffSize < QMIWDSBindMuxDataPortReqSize() )
+   {
+      return -ENOMEM;
+   }
+
+   // QMI WDA SET DATA FORMAT REQ
+   // Request
+   *(u8 *)(pBuffer + sizeof( sQMUX ))  = 0x00; //1
+
+   // Transaction ID
+   put_unaligned( cpu_to_le16(transactionID), (u16 *)(pBuffer + sizeof( sQMUX ) + 1) ); //2
+
+   // Message ID
+   put_unaligned( cpu_to_le16(0x00A2), (u16 *)(pBuffer + sizeof( sQMUX ) + 3) ); //2
+
+   // Size of TLV's
+   put_unaligned( cpu_to_le16(0x0016), (u16 *)(pBuffer + sizeof( sQMUX ) + 5)); //2
+
+   /* TLVType Peripheral End Point ID Format 1 byte  */
+   *(u8 *)(pBuffer + sizeof( sQMUX ) +  7) = 0x10; //Peripheral End Point ID
+   /* TLVLength  2 bytes - see spec */
+   put_unaligned( cpu_to_le16(0x0008), (u16 *)(pBuffer + sizeof( sQMUX ) + 8));
+   if (1 == platid){
+       //ep_type 4 bit
+       put_unaligned( cpu_to_le32(0x00000005), (u32 *)(pBuffer + sizeof( sQMUX ) + 10));
+       //iface_id 4 bit
+       put_unaligned( cpu_to_le32(0x00000008), (u32 *)(pBuffer + sizeof( sQMUX ) + 14));
+   }else if (2 == platid){
+       //ep_type 4 bit
+       put_unaligned( cpu_to_le32(0x00000002), (u32 *)(pBuffer + sizeof( sQMUX ) + 10));
+       //iface_id 4 bit
+       iface_id = GetDeviceInterfaceNumber();
+       put_unaligned( cpu_to_le32(iface_id), (u32 *)(pBuffer + sizeof( sQMUX ) + 14));
+       PrintQMIHex((pBuffer + sizeof( sQMUX ) + 14),4);
+#if 0
+#ifdef RMNET_FG150_90DB
+       put_unaligned( cpu_to_le32(0x00000002), (u32 *)(pBuffer + sizeof( sQMUX ) + 14)); //for 0x05c6/90db
+#else
+       put_unaligned( cpu_to_le32(0x00000004), (u32 *)(pBuffer + sizeof( sQMUX ) + 14));
+#endif      
+#endif 
+   }
+
+   //TLVType Mux ID 1 bit
+   *(u8 *)(pBuffer + sizeof( sQMUX ) + 18) = 0x11;
+   /* TLVLength 2 bytes */
+   put_unaligned( cpu_to_le16(0x0001), (u16 *)(pBuffer + sizeof( sQMUX ) + 19));
+   /* Mux ID of the logical data channel to which the client binds. The default value is 0. 1 byte */
+   *(u8 *)(pBuffer + sizeof( sQMUX ) + 21) = 0x0;
+   DBG("#### Mux ID : 0x%x \n",*(u8 *)(pBuffer + sizeof( sQMUX ) + 21));
+
+   //TLVType of the client that requests the binding
+   *(u8 *)(pBuffer + sizeof( sQMUX ) + 22) = 0x13;
+   put_unaligned( cpu_to_le16(0x0004), (u16 *)(pBuffer + sizeof( sQMUX ) + 23));
+   put_unaligned( cpu_to_le32(0x00000001), (u32 *)(pBuffer + sizeof( sQMUX ) + 25));  //Tethered 
+
+   // success
+   return QMIWDSBindMuxDataPortReqSize();
+}
+
+
+
+
+/*===========================================================================
+METHOD:
+   QMIWDSBindMuxDataPortPreReqSize (Public Method)
+
+DESCRIPTION:
+   Get size of buffer needed for QMUX + QMIWDSBindMuxDataPortReq
+ 
+RETURN VALUE:
+   u16 - size of buffer
+===========================================================================*/
+u16 QMIWDSBindMuxDataPortPreReqSize( void )
+{
+   return sizeof( sQMUX ) + 22;
+}
+
+
+
+/*===========================================================================
+METHOD:
+
+   QMIWDSBindMuxDataPortPreReq (Public Method)
+
+DESCRIPTION:
+
+   Fill buffer with QMI WDS Bind Mux Data Port Request
+
+PARAMETERS
+
+   pBuffer         [ 0 ] - Buffer to be filled
+   buffSize        [ I ] - Size of pBuffer
+   transactionID   [ I ] - Transaction ID
+
+
+RETURN VALUE:
+   int - Positive for resulting size of pBuffer
+
+         Negative errno for error
+===========================================================================*/
+int QMIWDSBindMuxDataPortPreReq(
+   void *   pBuffer,
+   u16      buffSize,
+   u16      transactionID,
+   unsigned int index )
+{
+   int iface_id;
+
+   if (pBuffer == 0 || buffSize < QMIWDSBindMuxDataPortPreReqSize() )
+   {
+      return -ENOMEM;
+   }
+
+   // QMI WDA SET DATA FORMAT REQ
+   // Request
+   *(u8 *)(pBuffer + sizeof( sQMUX ))  = 0x00; //1
+
+   // Transaction ID
+   put_unaligned( cpu_to_le16(transactionID), (u16 *)(pBuffer + sizeof( sQMUX ) + 1) ); //2
+
+   // Message ID
+   put_unaligned( cpu_to_le16(0x00A2), (u16 *)(pBuffer + sizeof( sQMUX ) + 3) ); //2
+
+   // Size of TLV's
+   put_unaligned( cpu_to_le16(0x000F), (u16 *)(pBuffer + sizeof( sQMUX ) + 5)); //2
+
+   /* TLVType Peripheral End Point ID Format 1 byte  */
+   *(u8 *)(pBuffer + sizeof( sQMUX ) +  7) = 0x10; //Peripheral End Point ID
+   /* TLVLength  2 bytes - see spec */
+   put_unaligned( cpu_to_le16(0x0008), (u16 *)(pBuffer + sizeof( sQMUX ) + 8));
+   //ep_type 4 bit
+   put_unaligned( cpu_to_le32(0x00000002), (u32 *)(pBuffer + sizeof( sQMUX ) + 10));
+   //iface_id 4 bit
+   iface_id = GetDeviceInterfaceNumber();
+   put_unaligned( cpu_to_le32(iface_id), (u32 *)(pBuffer + sizeof( sQMUX ) + 14));
+   PrintQMIHex((pBuffer + sizeof( sQMUX ) + 14),4);
+#if 0
+#ifdef RMNET_FG150_90DB
+   put_unaligned( cpu_to_le32(0x00000002), (u32 *)(pBuffer + sizeof( sQMUX ) + 14));   //for 0x05c6/0x90db
+#else
+   put_unaligned( cpu_to_le32(0x00000004), (u32 *)(pBuffer + sizeof( sQMUX ) + 14));
+#endif 
+#endif
+
+   //TLVType Mux ID 1 bit
+   *(u8 *)(pBuffer + sizeof( sQMUX ) + 18) = 0x11;
+   /* TLVLength 2 bytes */
+   put_unaligned( cpu_to_le16(0x0001), (u16 *)(pBuffer + sizeof( sQMUX ) + 19));
+   /* Mux ID of the logical data channel to which the client binds. The default value is 0. 1 byte */
+   DBG("#### Mux ID[%d] of the logical data channel to which the client binds \n",index);
+   *(u8 *)(pBuffer + sizeof( sQMUX ) + 21) = index;
+
+   // success
+   return QMIWDSBindMuxDataPortPreReqSize();
+}
+
+
+
+
+/*===========================================================================
+METHOD:
+   QMICTLSyncReq (Public Method)
+
+DESCRIPTION:
+   Fill buffer with QMI CTL Sync Request
+
+PARAMETERS
+   pBuffer         [ 0 ] - Buffer to be filled
+   buffSize        [ I ] - Size of pBuffer
+   transactionID   [ I ] - Transaction ID
+
+RETURN VALUE:
+   int - Positive for resulting size of pBuffer
+         Negative errno for error
+===========================================================================*/
+int QMICTLSyncReq(
+   void *   pBuffer,
+   u16      buffSize,
+   u16      transactionID )
+{
+   if (pBuffer == 0 || buffSize < QMICTLSyncReqSize() )
+   {
+      return -ENOMEM;
+   }
+
+   // Request
+   *(u8 *)(pBuffer + sizeof( sQMUX ))  = 0x00;
+   // Transaction ID
+   *(u8 *)(pBuffer + sizeof( sQMUX ) + 1) = transactionID;
+   // Message ID
+   put_unaligned( cpu_to_le16(0x0027), (u16 *)(pBuffer + sizeof( sQMUX ) + 2) );
+   // Size of TLV's
+   put_unaligned( cpu_to_le16(0x0000), (u16 *)(pBuffer + sizeof( sQMUX ) + 4) );
+
+  // success
+  return sizeof( sQMUX ) + 6;
+}
+
+/*=========================================================================*/
+// Parse data from QMI responses
+/*=========================================================================*/
+
+/*===========================================================================
+METHOD:
+   QMICTLGetClientIDResp (Public Method)
+
+DESCRIPTION:
+   Parse the QMI CTL Get Client ID Resp
+
+PARAMETERS
+   pBuffer         [ I ] - Buffer to be parsed
+   buffSize        [ I ] - Size of pBuffer
+   pClientID       [ 0 ] - Recieved client ID
+
+RETURN VALUE:
+   int - 0 for success
+         Negative errno for error
+===========================================================================*/
+int QMICTLGetClientIDResp(
+   void * pBuffer,
+   u16    buffSize,
+   u16 *  pClientID )
+{
+   int result;
+   
+   // Ignore QMUX and SDU
+   //    QMI CTL SDU is 2 bytes, not 3
+   u8 offset = sizeof( sQMUX ) + 2;
+
+   if (pBuffer == 0 || buffSize < offset)
+   {
+      return -ENOMEM;
+   }
+
+   pBuffer = pBuffer + offset;
+   buffSize -= offset;
+
+   result = GetQMIMessageID( pBuffer, buffSize );
+   if (result != 0x22)
+   {
+      return -EFAULT;
+   }
+
+   result = ValidQMIMessage( pBuffer, buffSize );
+   if (result != 0)
+   {
+      return -EFAULT;
+   }
+
+   result = GetTLV( pBuffer, buffSize, 0x01, pClientID, 2 );
+   if (result != 2)
+   {
+      return -EFAULT;
+   }
+
+   return 0;
+}
+
+/*===========================================================================
+METHOD:
+   QMICTLReleaseClientIDResp (Public Method)
+
+DESCRIPTION:
+   Verify the QMI CTL Release Client ID Resp is valid
+
+PARAMETERS
+   pBuffer         [ I ] - Buffer to be parsed
+   buffSize        [ I ] - Size of pBuffer
+
+RETURN VALUE:
+   int - 0 for success
+         Negative errno for error
+===========================================================================*/
+int QMICTLReleaseClientIDResp(
+   void *   pBuffer,
+   u16      buffSize )
+{
+   int result;
+   
+   // Ignore QMUX and SDU
+   //    QMI CTL SDU is 2 bytes, not 3
+   u8 offset = sizeof( sQMUX ) + 2;
+
+   if (pBuffer == 0 || buffSize < offset)
+   {
+      return -ENOMEM;
+   }
+
+   pBuffer = pBuffer + offset;
+   buffSize -= offset;
+
+   result = GetQMIMessageID( pBuffer, buffSize );
+   if (result != 0x23)
+   {
+      return -EFAULT;
+   }
+
+   result = ValidQMIMessage( pBuffer, buffSize );
+   if (result != 0)
+   {
+      return -EFAULT;
+   }
+
+   return 0;
+}
+
+/*===========================================================================
+METHOD:
+   QMIWDSEventResp (Public Method)
+
+DESCRIPTION:
+   Parse the QMI WDS Set Event Report Resp/Indication or
+      QMI WDS Get PKG SRVC Status Resp/Indication
+
+   Return parameters will only be updated if value was received
+
+PARAMETERS
+   pBuffer         [ I ] - Buffer to be parsed
+   buffSize        [ I ] - Size of pBuffer
+   pTXOk           [ O ] - Number of transmitted packets without errors
+   pRXOk           [ O ] - Number of recieved packets without errors
+   pTXErr          [ O ] - Number of transmitted packets with framing errors
+   pRXErr          [ O ] - Number of recieved packets with framing errors
+   pTXOfl          [ O ] - Number of transmitted packets dropped due to overflow
+   pRXOfl          [ O ] - Number of recieved packets dropped due to overflow
+   pTXBytesOk      [ O ] - Number of transmitted bytes without errors
+   pRXBytesOk      [ O ] - Number of recieved bytes without errors
+   pbLinkState     [ 0 ] - Is the link active?
+   pbReconfigure   [ 0 ] - Must interface be reconfigured? (reset IP address)
+
+RETURN VALUE:
+   int - 0 for success
+         Negative errno for error
+===========================================================================*/
+int QMIWDSEventResp(
+   void *   pBuffer,
+   u16      buffSize,
+   u32 *    pTXOk,
+   u32 *    pRXOk,
+   u32 *    pTXErr,
+   u32 *    pRXErr,
+   u32 *    pTXOfl,
+   u32 *    pRXOfl,
+   u64 *    pTXBytesOk,
+   u64 *    pRXBytesOk,
+   bool *   pbLinkState,
+   bool *   pbReconfigure )
+{
+   int result;
+   u8 pktStatusRead[2];
+
+   // Ignore QMUX and SDU
+   u8 offset = sizeof( sQMUX ) + 3;
+
+   if (pBuffer == 0 
+   || buffSize < offset
+   || pTXOk == 0
+   || pRXOk == 0
+   || pTXErr == 0
+   || pRXErr == 0
+   || pTXOfl == 0
+   || pRXOfl == 0
+   || pTXBytesOk == 0
+   || pRXBytesOk == 0
+   || pbLinkState == 0
+   || pbReconfigure == 0 )
+   {
+      return -ENOMEM;
+   }
+
+   pBuffer = pBuffer + offset;
+   buffSize -= offset;
+
+   // Note: Indications.  No Mandatory TLV required
+
+   result = GetQMIMessageID( pBuffer, buffSize );
+   // QMI WDS Set Event Report Resp
+   if (result == 0x01)
+   {
+      // TLV's are not mandatory
+      GetTLV( pBuffer, buffSize, 0x10, (void*)pTXOk, 4 );
+      put_unaligned( le32_to_cpu(*pTXOk), pTXOk);
+      GetTLV( pBuffer, buffSize, 0x11, (void*)pRXOk, 4 );
+      put_unaligned( le32_to_cpu(*pRXOk), pRXOk);
+      GetTLV( pBuffer, buffSize, 0x12, (void*)pTXErr, 4 );
+      put_unaligned( le32_to_cpu(*pTXErr), pTXErr);
+      GetTLV( pBuffer, buffSize, 0x13, (void*)pRXErr, 4 );
+      put_unaligned( le32_to_cpu(*pRXErr), pRXErr);
+      GetTLV( pBuffer, buffSize, 0x14, (void*)pTXOfl, 4 );
+      put_unaligned( le32_to_cpu(*pTXOfl), pTXOfl);
+      GetTLV( pBuffer, buffSize, 0x15, (void*)pRXOfl, 4 );
+      put_unaligned( le32_to_cpu(*pRXOfl), pRXOfl);
+      GetTLV( pBuffer, buffSize, 0x16, (void*)pTXOfl, 4 );
+      put_unaligned( le32_to_cpu(*pTXOfl), pTXOfl);
+      GetTLV( pBuffer, buffSize, 0x17, (void*)pRXOfl, 4 );
+      put_unaligned( le32_to_cpu(*pRXOfl), pRXOfl);
+      GetTLV( pBuffer, buffSize, 0x19, (void*)pTXBytesOk, 8 );
+      put_unaligned( le64_to_cpu(*pTXBytesOk), pTXBytesOk);
+      GetTLV( pBuffer, buffSize, 0x1A, (void*)pRXBytesOk, 8 );
+      put_unaligned( le64_to_cpu(*pRXBytesOk), pRXBytesOk);
+   }
+   // QMI WDS Get PKG SRVC Status Resp
+   else if (result == 0x22)
+   {
+      result = GetTLV( pBuffer, buffSize, 0x01, &pktStatusRead[0], 2 );
+      // 1 or 2 bytes may be received
+      if (result >= 1)
+      {
+         if (pktStatusRead[0] == 0x02)
+         {
+            *pbLinkState = true;
+         }
+         else
+         {
+            *pbLinkState = false;
+         }
+      }
+      if (result == 2)
+      {
+         if (pktStatusRead[1] == 0x01)
+         {
+            *pbReconfigure = true;
+         }
+         else
+         {
+            *pbReconfigure = false;
+         }
+      }
+      
+      if (result < 0)
+      {
+         return result;
+      }
+   }
+   else
+   {
+      return -EFAULT;
+   }
+
+   return 0;
+}
+
+/*===========================================================================
+METHOD:
+   QMIDMSGetMEIDResp (Public Method)
+
+DESCRIPTION:
+   Parse the QMI DMS Get Serial Numbers Resp
+
+PARAMETERS
+   pBuffer         [ I ] - Buffer to be parsed
+   buffSize        [ I ] - Size of pBuffer
+   pMEID           [ O ] - Device MEID
+   meidSize        [ I ] - Size of MEID buffer (at least 14)
+
+RETURN VALUE:
+   int - 0 for success
+         Negative errno for error
+===========================================================================*/
+int QMIDMSGetMEIDResp(
+   void *   pBuffer,
+   u16      buffSize,
+   char *   pMEID,
+   int      meidSize )
+{
+   int result;
+
+   // Ignore QMUX and SDU
+   u8 offset = sizeof( sQMUX ) + 3;
+
+   if (pBuffer == 0 || buffSize < offset || meidSize < 14)
+   {
+      return -ENOMEM;
+   }
+
+   pBuffer = pBuffer + offset;
+   buffSize -= offset;
+
+   result = GetQMIMessageID( pBuffer, buffSize );
+   if (result != 0x25)
+   {
+      return -EFAULT;
+   }
+
+   result = ValidQMIMessage( pBuffer, buffSize );
+   if (result != 0)
+   {
+      return -EFAULT;
+   }
+
+   result = GetTLV( pBuffer, buffSize, 0x12, (void*)pMEID, 14 );
+   if (result != 14)
+   {
+      return -EFAULT;
+   }
+
+   return 0;
+}
+
+/*===========================================================================
+METHOD:
+   QMIWDASetDataFormatResp (Public Method)
+
+DESCRIPTION:
+   Parse the QMI WDA Set Data Format Response
+
+PARAMETERS
+   pBuffer         [ I ] - Buffer to be parsed
+   buffSize        [ I ] - Size of pBuffer
+
+RETURN VALUE:
+   int - 0 for success
+         Negative errno for error
+===========================================================================*/
+int QMIWDASetDataFormatResp(
+   void *   pBuffer,
+   u16      buffSize )
+{
+
+   int result;
+
+   u8 pktLinkProtocol[4];
+
+   // Ignore QMUX and SDU
+   // QMI SDU is 3 bytes
+   u8 offset = sizeof( sQMUX ) + 3;
+
+   if (pBuffer == 0 || buffSize < offset)
+   {
+      return -ENOMEM;
+   }
+
+   pBuffer = pBuffer + offset;
+   buffSize -= offset;
+
+   result = GetQMIMessageID( pBuffer, buffSize );
+   if (result != 0x20)
+   {
+      return -EFAULT;
+   }
+
+   /* Check response message result TLV */
+   result = ValidQMIMessage( pBuffer, buffSize );
+   if (result != 0)
+   {
+      DBG("EFAULT: Data Format Mode Bad Response\n"); 
+//      return -EFAULT;
+      return 0;
+   }
+
+   /* Check response message link protocol */
+   result = GetTLV( pBuffer, buffSize, 0x11,
+                     &pktLinkProtocol[0], 4);
+   if (result != 4)
+   {
+      DBG("EFAULT: Wrong TLV format\n"); 
+      return 0;
+      
+   }
+
+#ifdef DATA_MODE_RP
+   if (pktLinkProtocol[0] != 2)
+   {
+      DBG("EFAULT: Data Format Cannot be set to RawIP Mode\n"); 
+      return pktLinkProtocol[0];
+   }
+   DBG("Data Format Set to RawIP\n");
+#else
+   if (pktLinkProtocol[0] != 1)
+   {
+      DBG("EFAULT: Data Format Cannot be set to Ethernet Mode\n"); 
+      return pktLinkProtocol[0];
+   }
+   DBG("Data Format Set to Ethernet Mode \n");
+#endif
+
+   return pktLinkProtocol[0];
+}
+
+/*===========================================================================
+METHOD:
+   QMIWDSBindMuxDataPortResp (Public Method)
+
+DESCRIPTION:
+   Parse the QMI WDS Bind Mux Data Port Response
+
+PARAMETERS
+   pBuffer         [ I ] - Buffer to be parsed
+   buffSize        [ I ] - Size of pBuffer
+
+RETURN VALUE:
+   int - 0 for success
+         Negative errno for error
+===========================================================================*/
+int QMIWDSBindMuxDataPortResp(
+   void *   pBuffer,
+   u16      buffSize )
+{
+
+   int result;
+
+   u8 pktLinkProtocol[4];
+
+   // Ignore QMUX and SDU
+   // QMI SDU is 3 bytes
+   u8 offset = sizeof( sQMUX ) + 3;
+
+   if (pBuffer == 0 || buffSize < offset)
+   {
+      return -ENOMEM;
+   }
+
+   pBuffer = pBuffer + offset;
+   buffSize -= offset;
+
+   result = GetQMIMessageID( pBuffer, buffSize );
+   if (result != 0xA2)
+   {
+      return -EFAULT;
+   }
+
+   /* Check response message result TLV */
+   result = ValidQMIMessage( pBuffer, buffSize );
+   if (result != 0)
+   {
+      DBG("EFAULT: Data Format Mode Bad Response\n"); 
+      return 0;
+   }
+
+   /* Check response message link protocol */
+   result = GetTLV( pBuffer, buffSize, 0x02,
+                     &pktLinkProtocol[0], 4);
+   if (result != 4)
+   {
+      DBG("EFAULT: Wrong TLV format\n"); 
+      return 0;
+      
+   }
+
+   return pktLinkProtocol[0];
+}
+
+/*===========================================================================
+METHOD:
+   QMICTLSyncResp (Public Method)
+
+DESCRIPTION:
+   Validate the QMI CTL Sync Response
+
+PARAMETERS
+   pBuffer         [ I ] - Buffer to be parsed
+   buffSize        [ I ] - Size of pBuffer
+
+RETURN VALUE:
+   int - 0 for success
+         Negative errno for error
+===========================================================================*/
+int QMICTLSyncResp(
+   void *pBuffer,
+   u16  buffSize )
+{
+   int result;
+
+   // Ignore QMUX (2 bytes for QMI CTL) and SDU
+   u8 offset = sizeof( sQMUX ) + 2;
+
+   if (pBuffer == 0 || buffSize < offset)
+   {
+      return -ENOMEM;
+   }
+
+   pBuffer = pBuffer + offset;
+   buffSize -= offset;
+
+   result = GetQMIMessageID( pBuffer, buffSize );
+   if (result != 0x27)
+   {
+      return -EFAULT;
+   }
+
+   result = ValidQMIMessage( pBuffer, buffSize );
+
+   return result;
+}
diff -Naur a/drivers/net/usb/QMIDevice.c b/drivers/net/usb/QMIDevice.c
--- a/drivers/net/usb/QMIDevice.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/net/usb/QMIDevice.c	2020-01-15 10:22:25.011180592 +0800
@@ -0,0 +1,4303 @@
+/*===========================================================================
+FILE:
+   QMIDevice.c
+
+DESCRIPTION:
+   Functions related to the QMI interface device
+   
+FUNCTIONS:
+   Generic functions
+      IsDeviceValid
+      PrintHex
+      GobiSetDownReason
+      GobiClearDownReason
+      GobiTestDownReason
+
+   Driver level asynchronous read functions
+      ResubmitIntURB
+      ReadCallback
+      IntCallback
+      StartRead
+      KillRead
+
+   Internal read/write functions
+      ReadAsync
+      UpSem
+      ReadSync
+      WriteSyncCallback
+      WriteSync
+
+   Internal memory management functions
+      GetClientID
+      ReleaseClientID
+      FindClientMem
+      AddToReadMemList
+      PopFromReadMemList
+      AddToNotifyList
+      NotifyAndPopNotifyList
+      AddToURBList
+      PopFromURBList
+
+   Internal userspace wrapper functions
+      UserspaceunlockedIOCTL
+
+   Userspace wrappers
+      UserspaceOpen
+      UserspaceIOCTL
+      UserspaceClose
+      UserspaceRead
+      UserspaceWrite
+      UserspacePoll
+
+   Initializer and destructor
+      RegisterQMIDevice
+      DeregisterQMIDevice
+
+   Driver level client management
+      QMIReady
+      QMIWDSCallback
+      SetupQMIWDSCallback
+      QMIDMSGetMEID
+
+Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of Code Aurora Forum nor
+      the names of its contributors may be used to endorse or promote
+      products derived from this software without specific prior written
+      permission.
+
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+===========================================================================*/
+
+//---------------------------------------------------------------------------
+// Include Files
+//---------------------------------------------------------------------------
+#include "QMIDevice.h"
+#include <asm/unaligned.h>
+#include <linux/module.h>
+//https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.11.1
+//from 4.11.1 that for_each_process func defined in sched/signal.h
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION( 4,11,0 ))
+#include <linux/sched/signal.h>
+#endif
+
+//-----------------------------------------------------------------------------
+// Definitions
+//-----------------------------------------------------------------------------
+
+extern int Gobi_debug;
+extern int interruptible;
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION( 2,6,22 ))
+static int s_interval;
+#endif
+
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION( 2,6,14 ))
+#include <linux/devfs_fs_kernel.h>
+static char devfs_name[32];
+int device_create(struct class *class,  struct device *parent, dev_t devt, const char *fmt, ...)
+{
+   va_list vargs;
+   struct class_device *class_dev;
+   int err;
+
+   va_start(vargs, fmt);
+   vsnprintf(devfs_name, sizeof(devfs_name), fmt, vargs);
+   va_end(vargs);
+
+   class_dev = class_device_create(class, devt, parent, "%s", devfs_name);
+   if (IS_ERR(class_dev)) {
+      err = PTR_ERR(class_dev);
+      goto out;
+   }
+
+   err = devfs_mk_cdev(devt, S_IFCHR|S_IRUSR|S_IWUSR|S_IRGRP, devfs_name);
+   if (err) {
+      class_device_destroy(class, devt);
+      goto out;
+   }
+
+   return 0;
+   
+out:
+   return err;   
+}
+
+void device_destroy(struct class *class, dev_t devt)
+{
+   class_device_destroy(class, devt);
+   devfs_remove(devfs_name);
+}
+#endif
+
+#ifdef CONFIG_PM
+// Prototype to GobiNetSuspend function
+int GobiNetSuspend(
+   struct usb_interface *     pIntf,
+   pm_message_t               powerEvent );
+#endif /* CONFIG_PM */
+
+// IOCTL to generate a client ID for this service type
+#define IOCTL_QMI_GET_SERVICE_FILE 0x8BE0 + 1
+
+// IOCTL to get the VIDPID of the device
+#define IOCTL_QMI_GET_DEVICE_VIDPID 0x8BE0 + 2
+
+// IOCTL to get the MEID of the device
+#define IOCTL_QMI_GET_DEVICE_MEID 0x8BE0 + 3
+
+#define IOCTL_QMI_RELEASE_SERVICE_FILE_IOCTL  (0x8BE0 + 4)
+
+// CDC GET_ENCAPSULATED_RESPONSE packet
+#define CDC_GET_ENCAPSULATED_RESPONSE_LE 0x01A1ll
+#define CDC_GET_ENCAPSULATED_RESPONSE_BE 0xA101000000000000ll
+/* The following masks filter the common part of the encapsulated response
+ * packet value for Gobi and QMI devices, ie. ignore usb interface number
+ */
+#define CDC_RSP_MASK_BE 0xFFFFFFFF00FFFFFFll
+#define CDC_RSP_MASK_LE 0xFFFFFFE0FFFFFFFFll
+
+const int i = 1;
+#define is_bigendian() ( (*(char*)&i) == 0 )
+#define CDC_GET_ENCAPSULATED_RESPONSE(pcdcrsp, pmask)\
+{\
+   *pcdcrsp  = is_bigendian() ? CDC_GET_ENCAPSULATED_RESPONSE_BE \
+                          : CDC_GET_ENCAPSULATED_RESPONSE_LE ; \
+   *pmask = is_bigendian() ? CDC_RSP_MASK_BE \
+                           : CDC_RSP_MASK_LE; \
+}
+
+// CDC CONNECTION_SPEED_CHANGE indication packet
+#define CDC_CONNECTION_SPEED_CHANGE_LE 0x2AA1ll
+#define CDC_CONNECTION_SPEED_CHANGE_BE 0xA12A000000000000ll
+/* The following masks filter the common part of the connection speed change
+ * packet value for Gobi and QMI devices
+ */
+#define CDC_CONNSPD_MASK_BE 0xFFFFFFFFFFFF7FFFll
+#define CDC_CONNSPD_MASK_LE 0XFFF7FFFFFFFFFFFFll
+#define CDC_GET_CONNECTION_SPEED_CHANGE(pcdccscp, pmask)\
+{\
+   *pcdccscp  = is_bigendian() ? CDC_CONNECTION_SPEED_CHANGE_BE \
+                          : CDC_CONNECTION_SPEED_CHANGE_LE ; \
+   *pmask = is_bigendian() ? CDC_CONNSPD_MASK_BE \
+                           : CDC_CONNSPD_MASK_LE; \
+}
+
+#define SET_CONTROL_LINE_STATE_REQUEST_TYPE        0x21
+#define SET_CONTROL_LINE_STATE_REQUEST             0x22
+#define CONTROL_DTR                     0x01
+#define CONTROL_RTS                     0x02
+
+/*=========================================================================*/
+// UserspaceQMIFops
+//    QMI device's userspace file operations
+/*=========================================================================*/
+struct file_operations UserspaceQMIFops = 
+{
+   .owner     = THIS_MODULE,
+   .read      = UserspaceRead,
+   .write     = UserspaceWrite,
+#ifdef CONFIG_COMPAT
+   .compat_ioctl = UserspaceunlockedIOCTL,
+#endif
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION( 2,6,36 ))
+   .unlocked_ioctl = UserspaceunlockedIOCTL,
+#else
+   .ioctl     = UserspaceIOCTL,
+#endif
+   .open      = UserspaceOpen,
+   .flush     = UserspaceClose,
+   .poll      = UserspacePoll,
+};
+
+/*=========================================================================*/
+// Generic functions
+/*=========================================================================*/
+u8 QMIXactionIDGet( sGobiUSBNet *pDev)
+{
+   u8 transactionID;
+
+   if( 0 == (transactionID = atomic_add_return( 1, &pDev->mQMIDev.mQMICTLTransactionID)) )
+   {
+      transactionID = atomic_add_return( 1, &pDev->mQMIDev.mQMICTLTransactionID );
+   }
+   
+   return transactionID;
+}
+
+static struct usb_endpoint_descriptor *GetEndpoint(
+    struct usb_interface *pintf,
+    int type,
+    int dir )
+{
+   int i;
+   struct usb_host_interface *iface = pintf->cur_altsetting;
+   struct usb_endpoint_descriptor *pendp;
+
+   for( i = 0; i < iface->desc.bNumEndpoints; i++)
+   {
+      pendp = &iface->endpoint[i].desc;
+      if( ((pendp->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == dir)
+          &&
+          (usb_endpoint_type(pendp) == type) )
+      {
+         return pendp;
+      }
+   }
+
+   return NULL;
+}
+
+/*===========================================================================
+METHOD:
+   IsDeviceValid (Public Method)
+
+DESCRIPTION:
+   Basic test to see if device memory is valid
+
+PARAMETERS:
+   pDev     [ I ] - Device specific memory
+
+RETURN VALUE:
+   bool
+===========================================================================*/
+bool IsDeviceValid( sGobiUSBNet * pDev )
+{
+   if (pDev == NULL)
+   {
+      return false;
+   }
+
+   if (pDev->mbQMIValid == false)
+   {
+      return false;
+   }
+   
+   return true;
+} 
+
+/*===========================================================================
+METHOD:
+   PrintHex (Public Method)
+
+DESCRIPTION:
+   Print Hex data, for debug purposes
+
+PARAMETERS:
+   pBuffer       [ I ] - Data buffer
+   bufSize       [ I ] - Size of data buffer
+
+RETURN VALUE:
+   None
+===========================================================================*/
+void PrintHex(
+   void *      pBuffer,
+   u16         bufSize )
+{
+   char * pPrintBuf;
+   u16 pos;
+   int status;
+   
+   if (Gobi_debug != 1)
+   {
+       return;
+   }
+
+   pPrintBuf = kmalloc( bufSize * 3 + 1, GFP_ATOMIC );
+   if (pPrintBuf == NULL)
+   {
+      DBG( "Unable to allocate buffer\n" );
+      return;
+   }
+   memset( pPrintBuf, 0 , bufSize * 3 + 1 );
+   
+   for (pos = 0; pos < bufSize; pos++)
+   {
+      status = snprintf( (pPrintBuf + (pos * 3)), 
+                         4, 
+                         "%02X ", 
+                         *(u8 *)(pBuffer + pos) );
+      if (status != 3)
+      {
+         DBG( "snprintf error %d\n", status );
+         kfree( pPrintBuf );
+         return;
+      }
+   }
+   
+   DBG( "   : %s\n", pPrintBuf );
+
+   kfree( pPrintBuf );
+   pPrintBuf = NULL;
+   return;   
+}
+
+/*===========================================================================
+METHOD:
+   GobiSetDownReason (Public Method)
+
+DESCRIPTION:
+   Sets mDownReason and turns carrier off
+
+PARAMETERS
+   pDev     [ I ] - Device specific memory
+   reason   [ I ] - Reason device is down
+
+RETURN VALUE:
+   None
+===========================================================================*/
+void GobiSetDownReason(
+   sGobiUSBNet *    pDev,
+   u8                 reason )
+{
+   set_bit( reason, &pDev->mDownReason );
+   DBG("%s reason=%d, mDownReason=%x\n", __func__, reason, (unsigned)pDev->mDownReason);
+   
+   netif_carrier_off( pDev->mpNetDev->net );
+}
+
+/*===========================================================================
+METHOD:
+   GobiClearDownReason (Public Method)
+
+DESCRIPTION:
+   Clear mDownReason and may turn carrier on
+
+PARAMETERS
+   pDev     [ I ] - Device specific memory
+   reason   [ I ] - Reason device is no longer down
+
+RETURN VALUE:
+   None
+===========================================================================*/
+void GobiClearDownReason(
+   sGobiUSBNet *    pDev,
+   u8                 reason )
+{
+   clear_bit( reason, &pDev->mDownReason );
+   
+   DBG("%s ***yangyx ,(set carrier on)reason=%d, mDownReason=%x\n", __func__, reason, (unsigned)pDev->mDownReason);
+#if 0 //(LINUX_VERSION_CODE >= KERNEL_VERSION( 3,11,0 ))
+    netif_carrier_on( pDev->mpNetDev->net );
+#else
+   if (pDev->mDownReason == 0)
+   {
+      netif_carrier_on( pDev->mpNetDev->net );
+   }
+#endif
+}
+
+/*===========================================================================
+METHOD:
+   GobiTestDownReason (Public Method)
+
+DESCRIPTION:
+   Test mDownReason and returns whether reason is set
+
+PARAMETERS
+   pDev     [ I ] - Device specific memory
+   reason   [ I ] - Reason device is down
+
+RETURN VALUE:
+   bool
+===========================================================================*/
+bool GobiTestDownReason(
+   sGobiUSBNet *    pDev,
+   u8                 reason )
+{
+   return test_bit( reason, &pDev->mDownReason );
+}
+
+/*=========================================================================*/
+// Driver level asynchronous read functions
+/*=========================================================================*/
+
+/*===========================================================================
+METHOD:
+   ResubmitIntURB (Public Method)
+
+DESCRIPTION:
+   Resubmit interrupt URB, re-using same values
+
+PARAMETERS
+   pIntURB       [ I ] - Interrupt URB 
+
+RETURN VALUE:
+   int - 0 for success
+         negative errno for failure
+===========================================================================*/
+int ResubmitIntURB( struct urb * pIntURB )
+{
+   int status;
+   int interval;
+
+   // Sanity test
+   if ( (pIntURB == NULL)
+   ||   (pIntURB->dev == NULL) )
+   {
+      return -EINVAL;
+   }
+ 
+   // Interval needs reset after every URB completion
+#if (LINUX_VERSION_CODE > KERNEL_VERSION( 2,6,22 ))
+    interval = max((int)(pIntURB->ep->desc.bInterval),
+                  (pIntURB->dev->speed == USB_SPEED_HIGH) ? 7 : 3);
+#else
+    interval = s_interval;
+#endif
+
+   // Reschedule interrupt URB
+   usb_fill_int_urb( pIntURB,
+                     pIntURB->dev,
+                     pIntURB->pipe,
+                     pIntURB->transfer_buffer,
+                     pIntURB->transfer_buffer_length,
+                     pIntURB->complete,
+                     pIntURB->context,
+                     interval );
+   status = usb_submit_urb( pIntURB, GFP_ATOMIC );
+   if (status != 0)
+   {
+      DBG( "Error re-submitting Int URB %d\n", status );
+   }
+
+   return status;
+}
+
+/*===========================================================================
+METHOD:
+   ReadCallback (Public Method)
+
+DESCRIPTION:
+   Put the data in storage and notify anyone waiting for data
+
+PARAMETERS
+   pReadURB       [ I ] - URB this callback is run for
+
+RETURN VALUE:
+   None
+===========================================================================*/
+#if (LINUX_VERSION_CODE > KERNEL_VERSION( 2,6,14 ))
+void ReadCallback( struct urb * pReadURB )
+#else
+void ReadCallback(struct urb *pReadURB, struct pt_regs *regs)
+#endif
+{
+   int result;
+   u16 clientID;
+   sClientMemList * pClientMem;
+   void * pData;
+   void * pDataCopy;
+   u16 dataSize;
+   sGobiUSBNet * pDev;
+   unsigned long flags;
+   u16 transactionID;
+
+   if (pReadURB == NULL)
+   {
+      DBG( "bad read URB\n" );
+      return;
+   }
+   
+   pDev = pReadURB->context;
+   if (IsDeviceValid( pDev ) == false)
+   {
+      DBG( "Invalid device!\n" );
+      return;
+   }   
+
+   if (pReadURB->status != 0)
+   {
+      DBG( "Read status = %d\n", pReadURB->status );
+
+      // Resubmit the interrupt URB
+      ResubmitIntURB( pDev->mQMIDev.mpIntURB );
+
+      return;
+   }
+   DBG( "Read %d bytes\n", pReadURB->actual_length );
+   
+   pData = pReadURB->transfer_buffer;
+   dataSize = pReadURB->actual_length;
+
+   PrintHex( pData, dataSize );
+
+   result = ParseQMUX( &clientID,
+                       pData,
+                       dataSize );
+   if (result < 0)
+   {
+      DBG( "Read error parsing QMUX %d\n", result );
+
+      // Resubmit the interrupt URB
+      ResubmitIntURB( pDev->mQMIDev.mpIntURB );
+
+      return;
+   }
+   
+   // Grab transaction ID
+
+   // Data large enough?
+   if (dataSize < result + 3)
+   {
+      DBG( "Data buffer too small to parse\n" );
+
+      // Resubmit the interrupt URB
+      ResubmitIntURB( pDev->mQMIDev.mpIntURB );
+
+      return;
+   }
+   
+   // Transaction ID size is 1 for QMICTL, 2 for others
+   if (clientID == QMICTL)
+   {
+      transactionID = *(u8*)(pData + result + 1);
+   }
+   else
+   {
+      transactionID = le16_to_cpu( get_unaligned((u16*)(pData + result + 1)) );
+   }
+   
+   // Critical section
+   spin_lock_irqsave( &pDev->mQMIDev.mClientMemLock, flags );
+
+   // Find memory storage for this service and Client ID
+   // Not using FindClientMem because it can't handle broadcasts
+   pClientMem = pDev->mQMIDev.mpClientMemList;
+
+   while (pClientMem != NULL)
+   {
+      if (pClientMem->mClientID == clientID 
+      ||  (pClientMem->mClientID | 0xff00) == clientID)
+      {
+         // Make copy of pData
+         pDataCopy = kmalloc( dataSize, GFP_ATOMIC );
+         if (pDataCopy == NULL)
+         {
+            DBG( "Error allocating client data memory\n" );
+
+            // End critical section
+            spin_unlock_irqrestore( &pDev->mQMIDev.mClientMemLock, flags );
+
+            // Resubmit the interrupt URB
+            ResubmitIntURB( pDev->mQMIDev.mpIntURB );
+
+            return;             
+         }
+
+         memcpy( pDataCopy, pData, dataSize );
+
+         if (AddToReadMemList( pDev,
+                               pClientMem->mClientID,
+                               transactionID,
+                               pDataCopy,
+                               dataSize ) == false)
+         {
+            DBG( "Error allocating pReadMemListEntry "
+                 "read will be discarded\n" );
+            kfree( pDataCopy );
+            
+            // End critical section
+            spin_unlock_irqrestore( &pDev->mQMIDev.mClientMemLock, flags );
+
+            // Resubmit the interrupt URB
+            ResubmitIntURB( pDev->mQMIDev.mpIntURB );
+
+            return;
+         }
+
+         // Success
+         VDBG( "Creating new readListEntry for client 0x%04X, TID %x\n",
+              clientID,
+              transactionID );
+
+         // Notify this client data exists
+         NotifyAndPopNotifyList( pDev,
+                                 pClientMem->mClientID,
+                                 transactionID );
+
+         // Possibly notify poll() that data exists
+         wake_up_interruptible_sync( &pClientMem->mWaitQueue );
+
+         // Not a broadcast
+         if (clientID >> 8 != 0xff)
+         {
+            break;
+         }
+      }
+      
+      // Next element
+      pClientMem = pClientMem->mpNext;
+   }
+   
+   // End critical section
+   spin_unlock_irqrestore( &pDev->mQMIDev.mClientMemLock, flags );
+   
+   // Resubmit the interrupt URB
+   ResubmitIntURB( pDev->mQMIDev.mpIntURB );
+}
+
+/*===========================================================================
+METHOD:
+   IntCallback (Public Method)
+
+DESCRIPTION:
+   Data is available, fire off a read URB
+
+PARAMETERS
+   pIntURB       [ I ] - URB this callback is run for
+
+RETURN VALUE:
+   None
+===========================================================================*/
+#if (LINUX_VERSION_CODE > KERNEL_VERSION( 2,6,14 ))
+void IntCallback( struct urb * pIntURB )
+{
+#else
+void IntCallback(struct urb *pIntURB, struct pt_regs *regs)
+{
+#endif
+   int status;
+   u64 CDCEncResp;
+   u64 CDCEncRespMask;
+   
+   sGobiUSBNet * pDev = (sGobiUSBNet *)pIntURB->context;
+   if (IsDeviceValid( pDev ) == false)
+   {
+      DBG( "Invalid device!\n" );
+      return;
+   }
+
+   // Verify this was a normal interrupt
+   if (pIntURB->status != 0)
+   {
+        DBG( "IntCallback: Int status = %d\n", pIntURB->status );
+      
+      // Ignore EOVERFLOW errors
+      if (pIntURB->status != -EOVERFLOW)
+      {
+         // Read 'thread' dies here
+         return;
+      }
+   }
+   else
+   {
+      //TODO cast transfer_buffer to struct usb_cdc_notification
+      
+      // CDC GET_ENCAPSULATED_RESPONSE
+      CDC_GET_ENCAPSULATED_RESPONSE(&CDCEncResp, &CDCEncRespMask)
+
+      VDBG( "IntCallback: Encapsulated Response = 0x%llx\n",
+          (*(u64*)pIntURB->transfer_buffer));
+
+      if ((pIntURB->actual_length == 8)
+      &&  ((*(u64*)pIntURB->transfer_buffer & CDCEncRespMask) == CDCEncResp ) )
+
+      {
+         // Time to read
+         usb_fill_control_urb( pDev->mQMIDev.mpReadURB,
+                               pDev->mpNetDev->udev,
+                               usb_rcvctrlpipe( pDev->mpNetDev->udev, 0 ),
+                               (unsigned char *)pDev->mQMIDev.mpReadSetupPacket,
+                               pDev->mQMIDev.mpReadBuffer,
+                               DEFAULT_READ_URB_LENGTH,
+                               ReadCallback,
+                               pDev );
+         status = usb_submit_urb( pDev->mQMIDev.mpReadURB, GFP_ATOMIC );
+         if (status != 0)
+         {
+            DBG( "Error submitting Read URB %d\n", status );
+
+            // Resubmit the interrupt urb
+            ResubmitIntURB( pIntURB );
+            return;
+         }
+
+         // Int URB will be resubmitted during ReadCallback
+         return;
+      }
+      // CDC CONNECTION_SPEED_CHANGE
+      else if ((pIntURB->actual_length == 16)
+           &&  (CDC_GET_CONNECTION_SPEED_CHANGE(&CDCEncResp, &CDCEncRespMask))
+           &&  ((*(u64*)pIntURB->transfer_buffer & CDCEncRespMask) == CDCEncResp ) )
+      {
+         DBG( "IntCallback: Connection Speed Change = 0x%llx\n",
+              (*(u64*)pIntURB->transfer_buffer));
+
+         // if upstream or downstream is 0, stop traffic.  Otherwise resume it
+         if ((*(u32*)(pIntURB->transfer_buffer + 8) == 0)
+         ||  (*(u32*)(pIntURB->transfer_buffer + 12) == 0))
+         {
+            GobiSetDownReason( pDev, CDC_CONNECTION_SPEED );
+            DBG( "traffic stopping due to CONNECTION_SPEED_CHANGE\n" );
+         }
+         else
+         {
+            GobiClearDownReason( pDev, CDC_CONNECTION_SPEED );
+            DBG( "resuming traffic due to CONNECTION_SPEED_CHANGE\n" );
+         }
+      }
+      else
+      {
+         DBG( "ignoring invalid interrupt in packet\n" );
+         PrintHex( pIntURB->transfer_buffer, pIntURB->actual_length );
+      }
+   }
+
+   // Resubmit the interrupt urb
+   ResubmitIntURB( pIntURB );
+
+   return;
+}
+
+/*===========================================================================
+METHOD:
+   StartRead (Public Method)
+
+DESCRIPTION:
+   Start continuous read "thread" (callback driven)
+
+   Note: In case of error, KillRead() should be run
+         to remove urbs and clean up memory.
+   
+PARAMETERS:
+   pDev     [ I ] - Device specific memory
+
+RETURN VALUE:
+   int - 0 for success
+         negative errno for failure
+===========================================================================*/
+int StartRead( sGobiUSBNet * pDev )
+{
+   int interval;
+   struct usb_endpoint_descriptor *pendp;
+
+   if (IsDeviceValid( pDev ) == false)
+   {
+      DBG( "Invalid device!\n" );
+      return -ENXIO;
+   }
+   
+   // Allocate URB buffers
+   pDev->mQMIDev.mpReadURB = usb_alloc_urb( 0, GFP_KERNEL );
+   if (pDev->mQMIDev.mpReadURB == NULL)
+   {
+      DBG( "Error allocating read urb\n" );
+      return -ENOMEM;
+   }
+   
+   pDev->mQMIDev.mpIntURB = usb_alloc_urb( 0, GFP_KERNEL );
+   if (pDev->mQMIDev.mpIntURB == NULL)
+   {
+      DBG( "Error allocating int urb\n" );
+      usb_free_urb( pDev->mQMIDev.mpReadURB );
+      pDev->mQMIDev.mpReadURB = NULL;
+      return -ENOMEM;
+   }
+
+   // Create data buffers
+   pDev->mQMIDev.mpReadBuffer = kmalloc( DEFAULT_READ_URB_LENGTH, GFP_KERNEL );
+   if (pDev->mQMIDev.mpReadBuffer == NULL)
+   {
+      DBG( "Error allocating read buffer\n" );
+      usb_free_urb( pDev->mQMIDev.mpIntURB );
+      pDev->mQMIDev.mpIntURB = NULL;
+      usb_free_urb( pDev->mQMIDev.mpReadURB );
+      pDev->mQMIDev.mpReadURB = NULL;
+      return -ENOMEM;
+   }
+   
+   pDev->mQMIDev.mpIntBuffer = kmalloc( 64, GFP_KERNEL );
+   if (pDev->mQMIDev.mpIntBuffer == NULL)
+   {
+      DBG( "Error allocating int buffer\n" );
+      kfree( pDev->mQMIDev.mpReadBuffer );
+      pDev->mQMIDev.mpReadBuffer = NULL;
+      usb_free_urb( pDev->mQMIDev.mpIntURB );
+      pDev->mQMIDev.mpIntURB = NULL;
+      usb_free_urb( pDev->mQMIDev.mpReadURB );
+      pDev->mQMIDev.mpReadURB = NULL;
+      return -ENOMEM;
+   }      
+   
+   pDev->mQMIDev.mpReadSetupPacket = kmalloc( sizeof( sURBSetupPacket ), 
+                                              GFP_KERNEL );
+   if (pDev->mQMIDev.mpReadSetupPacket == NULL)
+   {
+      DBG( "Error allocating setup packet buffer\n" );
+      kfree( pDev->mQMIDev.mpIntBuffer );
+      pDev->mQMIDev.mpIntBuffer = NULL;
+      kfree( pDev->mQMIDev.mpReadBuffer );
+      pDev->mQMIDev.mpReadBuffer = NULL;
+      usb_free_urb( pDev->mQMIDev.mpIntURB );
+      pDev->mQMIDev.mpIntURB = NULL;
+      usb_free_urb( pDev->mQMIDev.mpReadURB );
+      pDev->mQMIDev.mpReadURB = NULL;
+      return -ENOMEM;
+   }
+
+   // CDC Get Encapsulated Response packet
+   pDev->mQMIDev.mpReadSetupPacket->mRequestType = 0xA1;
+   pDev->mQMIDev.mpReadSetupPacket->mRequestCode = 1;
+   pDev->mQMIDev.mpReadSetupPacket->mValue = 0;
+   pDev->mQMIDev.mpReadSetupPacket->mIndex =
+      cpu_to_le16(pDev->mpIntf->cur_altsetting->desc.bInterfaceNumber);  /* interface number */
+   pDev->mQMIDev.mpReadSetupPacket->mLength = cpu_to_le16(DEFAULT_READ_URB_LENGTH);
+
+   pendp = GetEndpoint(pDev->mpIntf, USB_ENDPOINT_XFER_INT, USB_DIR_IN);
+   if (pendp == NULL)
+   {
+      DBG( "Invalid interrupt endpoint!\n" );
+      kfree(pDev->mQMIDev.mpReadSetupPacket);
+      pDev->mQMIDev.mpReadSetupPacket = NULL;
+      kfree( pDev->mQMIDev.mpIntBuffer );
+      pDev->mQMIDev.mpIntBuffer = NULL;
+      kfree( pDev->mQMIDev.mpReadBuffer );
+      pDev->mQMIDev.mpReadBuffer = NULL;
+      usb_free_urb( pDev->mQMIDev.mpIntURB );
+      pDev->mQMIDev.mpIntURB = NULL;
+      usb_free_urb( pDev->mQMIDev.mpReadURB );
+      pDev->mQMIDev.mpReadURB = NULL;
+      return -ENXIO;
+   }
+
+   // Interval needs reset after every URB completion
+   interval = max((int)(pendp->bInterval),
+                  (pDev->mpNetDev->udev->speed == USB_SPEED_HIGH) ? 7 : 3);
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION( 2,6,22 ))
+    s_interval = interval;
+#endif
+   
+   // Schedule interrupt URB
+   usb_fill_int_urb( pDev->mQMIDev.mpIntURB,
+                     pDev->mpNetDev->udev,
+                     /* QMI interrupt endpoint for the following
+                      * interface configuration: DM, NMEA, MDM, NET
+                      */
+                     usb_rcvintpipe( pDev->mpNetDev->udev,
+                                     pendp->bEndpointAddress),
+                     pDev->mQMIDev.mpIntBuffer,
+                     min((int)le16_to_cpu(pendp->wMaxPacketSize), 64),
+                     IntCallback,
+                     pDev,
+                     interval );
+   return usb_submit_urb( pDev->mQMIDev.mpIntURB, GFP_KERNEL );
+}
+
+/*===========================================================================
+METHOD:
+   KillRead (Public Method)
+
+DESCRIPTION:
+   Kill continuous read "thread"
+   
+PARAMETERS:
+   pDev     [ I ] - Device specific memory
+
+RETURN VALUE:
+   None
+===========================================================================*/
+void KillRead( sGobiUSBNet * pDev )
+{
+   // Stop reading
+   if (pDev->mQMIDev.mpReadURB != NULL)
+   {
+      DBG( "Killng read URB\n" );
+      usb_kill_urb( pDev->mQMIDev.mpReadURB );
+   }
+
+   if (pDev->mQMIDev.mpIntURB != NULL)
+   {
+      DBG( "Killng int URB\n" );
+      usb_kill_urb( pDev->mQMIDev.mpIntURB );
+   }
+
+   // Release buffers
+   kfree( pDev->mQMIDev.mpReadSetupPacket );
+   pDev->mQMIDev.mpReadSetupPacket = NULL;
+   kfree( pDev->mQMIDev.mpReadBuffer );
+   pDev->mQMIDev.mpReadBuffer = NULL;
+   kfree( pDev->mQMIDev.mpIntBuffer );
+   pDev->mQMIDev.mpIntBuffer = NULL;
+   
+   // Release URB's
+   usb_free_urb( pDev->mQMIDev.mpReadURB );
+   pDev->mQMIDev.mpReadURB = NULL;
+   usb_free_urb( pDev->mQMIDev.mpIntURB );
+   pDev->mQMIDev.mpIntURB = NULL;
+}
+
+/*=========================================================================*/
+// Internal read/write functions
+/*=========================================================================*/
+
+/*===========================================================================
+METHOD:
+   ReadAsync (Public Method)
+
+DESCRIPTION:
+   Start asynchronous read
+   NOTE: Reading client's data store, not device
+
+PARAMETERS:
+   pDev              [ I ] - Device specific memory
+   clientID          [ I ] - Requester's client ID
+   transactionID     [ I ] - Transaction ID or 0 for any
+   pCallback         [ I ] - Callback to be executed when data is available
+   pData             [ I ] - Data buffer that willl be passed (unmodified) 
+                             to callback
+
+RETURN VALUE:
+   int - 0 for success
+         negative errno for failure
+===========================================================================*/
+int ReadAsync(
+   sGobiUSBNet *      pDev,
+   u16                clientID,
+   u16                transactionID,
+   void               (*pCallback)(sGobiUSBNet*, u16, void *),
+   void *             pData )
+{
+   sClientMemList * pClientMem;
+   sReadMemList ** ppReadMemList;
+   
+   unsigned long flags;
+
+   if (IsDeviceValid( pDev ) == false)
+   {
+      DBG( "Invalid device!\n" );
+      return -ENXIO;
+   }
+
+   // Critical section
+   spin_lock_irqsave( &pDev->mQMIDev.mClientMemLock, flags );
+
+   // Find memory storage for this client ID
+   pClientMem = FindClientMem( pDev, clientID );
+   if (pClientMem == NULL)
+   {
+      DBG( "Could not find matching client ID 0x%04X\n",
+           clientID );
+           
+      // End critical section
+      spin_unlock_irqrestore( &pDev->mQMIDev.mClientMemLock, flags );
+      return -ENXIO;
+   }
+   
+   ppReadMemList = &(pClientMem->mpList);
+   
+   // Does data already exist?
+   while (*ppReadMemList != NULL)
+   {
+      // Is this element our data?
+      if (transactionID == 0 
+      ||  transactionID == (*ppReadMemList)->mTransactionID)
+      {
+         // End critical section
+         spin_unlock_irqrestore( &pDev->mQMIDev.mClientMemLock, flags );
+
+         // Run our own callback
+         pCallback( pDev, clientID, pData );
+         
+         return 0;
+      }
+      
+      // Next
+      ppReadMemList = &(*ppReadMemList)->mpNext;
+   }
+
+   // Data not found, add ourself to list of waiters
+   if (AddToNotifyList( pDev,
+                        clientID,
+                        transactionID, 
+                        pCallback, 
+                        pData ) == false)
+   {
+      DBG( "Unable to register for notification\n" );
+   }
+
+   // End critical section
+   spin_unlock_irqrestore( &pDev->mQMIDev.mClientMemLock, flags );
+
+   // Success
+   return 0;
+}
+
+/*===========================================================================
+METHOD:
+   UpSem (Public Method)
+
+DESCRIPTION:
+   Notification function for synchronous read
+
+PARAMETERS:
+   pDev              [ I ] - Device specific memory
+   clientID          [ I ] - Requester's client ID
+   pData             [ I ] - Buffer that holds semaphore to be up()-ed
+
+RETURN VALUE:
+   None
+===========================================================================*/
+void UpSem( 
+   sGobiUSBNet * pDev,
+   u16             clientID,
+   void *          pData )
+{
+   VDBG( "0x%04X\n", clientID );
+        
+   up( (struct semaphore *)pData );
+   return;
+}
+
+/*===========================================================================
+METHOD:
+   ReadSync (Public Method)
+
+DESCRIPTION:
+   Start synchronous read
+   NOTE: Reading client's data store, not device
+
+PARAMETERS:
+   pDev              [ I ] - Device specific memory
+   ppOutBuffer       [I/O] - On success, will be filled with a 
+                             pointer to read buffer
+   clientID          [ I ] - Requester's client ID
+   transactionID     [ I ] - Transaction ID or 0 for any
+
+RETURN VALUE:
+   int - size of data read for success
+         negative errno for failure
+===========================================================================*/
+int ReadSync(
+   sGobiUSBNet *    pDev,
+   void **            ppOutBuffer,
+   u16                clientID,
+   u16                transactionID )
+{
+   int result;
+   sClientMemList * pClientMem;
+   sNotifyList ** ppNotifyList, * pDelNotifyListEntry;
+   struct semaphore readSem;
+   void * pData;
+   unsigned long flags;
+   u16 dataSize;
+
+   if (IsDeviceValid( pDev ) == false)
+   {
+      DBG( "Invalid device!\n" );
+      return -ENXIO;
+   }
+   
+   // Critical section
+   spin_lock_irqsave( &pDev->mQMIDev.mClientMemLock, flags );
+
+   // Find memory storage for this Client ID
+   pClientMem = FindClientMem( pDev, clientID );
+   if (pClientMem == NULL)
+   {
+      DBG( "Could not find matching client ID 0x%04X\n",
+           clientID );
+      
+      // End critical section
+      spin_unlock_irqrestore( &pDev->mQMIDev.mClientMemLock, flags );
+      return -ENXIO;
+   }
+   
+   // Note: in cases where read is interrupted, 
+   //    this will verify client is still valid
+   while (PopFromReadMemList( pDev,
+                              clientID,
+                              transactionID,
+                              &pData,
+                              &dataSize ) == false)
+   {
+      // Data does not yet exist, wait
+      sema_init( &readSem, 0 );
+
+      // Add ourself to list of waiters
+      if (AddToNotifyList( pDev, 
+                           clientID, 
+                           transactionID, 
+                           UpSem, 
+                           &readSem ) == false)
+      {
+         DBG( "unable to register for notification\n" );
+         spin_unlock_irqrestore( &pDev->mQMIDev.mClientMemLock, flags );
+         return -EFAULT;
+      }
+
+      // End critical section while we block
+      spin_unlock_irqrestore( &pDev->mQMIDev.mClientMemLock, flags );
+
+      // Wait for notification
+      result = down_interruptible( &readSem );
+      if (result != 0)
+      {
+         DBG( "Interrupted %d\n", result );
+
+         // readSem will fall out of scope, 
+         // remove from notify list so it's not referenced
+         spin_lock_irqsave( &pDev->mQMIDev.mClientMemLock, flags );
+         ppNotifyList = &(pClientMem->mpReadNotifyList);
+         pDelNotifyListEntry = NULL;
+
+         // Find and delete matching entry
+         while (*ppNotifyList != NULL)
+         {
+            if ((*ppNotifyList)->mpData == &readSem)
+            {
+               pDelNotifyListEntry = *ppNotifyList;
+               *ppNotifyList = (*ppNotifyList)->mpNext;
+               kfree( pDelNotifyListEntry );
+               break;
+            }
+
+            // Next
+            ppNotifyList = &(*ppNotifyList)->mpNext;
+         }
+
+         spin_unlock_irqrestore( &pDev->mQMIDev.mClientMemLock, flags );
+         return -EINTR;
+      }
+      
+      // Verify device is still valid
+      if (IsDeviceValid( pDev ) == false)
+      {
+         DBG( "Invalid device!\n" );
+         return -ENXIO;
+      }
+      
+      // Restart critical section and continue loop
+      spin_lock_irqsave( &pDev->mQMIDev.mClientMemLock, flags );
+   }
+   
+   // End Critical section
+   spin_unlock_irqrestore( &pDev->mQMIDev.mClientMemLock, flags );
+
+   // Success
+   *ppOutBuffer = pData;
+
+   return dataSize;
+}
+
+/*===========================================================================
+METHOD:
+   WriteSyncCallback (Public Method)
+
+DESCRIPTION:
+   Write callback
+
+PARAMETERS
+   pWriteURB       [ I ] - URB this callback is run for
+
+RETURN VALUE:
+   None
+===========================================================================*/
+#if (LINUX_VERSION_CODE > KERNEL_VERSION( 2,6,14 ))
+void WriteSyncCallback( struct urb * pWriteURB )
+#else
+void WriteSyncCallback(struct urb *pWriteURB, struct pt_regs *regs)
+#endif
+{
+   if (pWriteURB == NULL)
+   {
+      DBG( "null urb\n" );
+      return;
+   }
+
+   DBG( "Write status/size %d/%d\n", 
+        pWriteURB->status, 
+        pWriteURB->actual_length );
+
+   // Notify that write has completed by up()-ing semeaphore
+   up( (struct semaphore * )pWriteURB->context );
+   
+   return;
+}
+
+/*===========================================================================
+METHOD:
+   WriteSync (Public Method)
+
+DESCRIPTION:
+   Start synchronous write
+
+PARAMETERS:
+   pDev                 [ I ] - Device specific memory
+   pWriteBuffer         [ I ] - Data to be written
+   writeBufferSize      [ I ] - Size of data to be written
+   clientID             [ I ] - Client ID of requester
+
+RETURN VALUE:
+   int - write size (includes QMUX)
+         negative errno for failure
+===========================================================================*/
+int WriteSync(
+   sGobiUSBNet *          pDev,
+   char *                 pWriteBuffer,
+   int                    writeBufferSize,
+   u16                    clientID )
+{
+   int result;
+   struct semaphore writeSem;
+   struct urb * pWriteURB;
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION( 4,12,14 ))
+   sURBSetupPacket writeSetup;
+#else
+   struct usb_ctrlrequest *pWriteSetup;
+#endif
+   unsigned long flags;
+
+   if (IsDeviceValid( pDev ) == false)
+   {
+      DBG( "Invalid device!\n" );
+      return -ENXIO;
+   }
+
+   pWriteURB = usb_alloc_urb( 0, GFP_KERNEL );
+   if (pWriteURB == NULL)
+   {
+      DBG( "URB mem error\n" );
+      return -ENOMEM;
+   }
+
+   // Fill writeBuffer with QMUX
+   result = FillQMUX( clientID, pWriteBuffer, writeBufferSize );
+   if (result < 0)
+   {
+      usb_free_urb( pWriteURB );
+      return result;
+   }
+
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION( 4,12,14 ))
+   // CDC Send Encapsulated Request packet
+   writeSetup.mRequestType = 0x21;
+   writeSetup.mRequestCode = 0;
+   writeSetup.mValue = 0;
+   writeSetup.mIndex = cpu_to_le16(pDev->mpIntf->cur_altsetting->desc.bInterfaceNumber);
+   writeSetup.mLength = cpu_to_le16(writeBufferSize);
+
+   // Create URB   
+   usb_fill_control_urb( pWriteURB,
+                         pDev->mpNetDev->udev,
+                         usb_sndctrlpipe( pDev->mpNetDev->udev, 0 ),
+                         (unsigned char *)&writeSetup,
+                         (void*)pWriteBuffer,
+                         writeBufferSize,
+                         NULL,
+                         pDev );
+ 
+#else
+   pWriteSetup = kmalloc(sizeof(struct usb_ctrlrequest), GFP_ATOMIC);
+   if (pWriteSetup == NULL)
+   {
+      DBG( "malloc usb_ctrlrequest mem error\n" );
+      return -ENOMEM;
+   }
+   pWriteSetup->bRequestType = 0x21;
+   pWriteSetup->bRequest = 0;
+   pWriteSetup->wValue = 0;
+   pWriteSetup->wIndex = cpu_to_le16(pDev->mpIntf->cur_altsetting->desc.bInterfaceNumber);
+   pWriteSetup->wLength = cpu_to_le16(writeBufferSize);
+
+   // Create URB   
+   usb_fill_control_urb( pWriteURB,
+                         pDev->mpNetDev->udev,
+                         usb_sndctrlpipe( pDev->mpNetDev->udev, 0 ),
+                         (void *)pWriteSetup,
+                         (void*)pWriteBuffer,
+                         writeBufferSize,
+                         NULL,
+                         pDev );
+#endif
+
+   DBG( "Actual Write:\n" );
+   PrintHex( pWriteBuffer, writeBufferSize );
+
+   sema_init( &writeSem, 0 );
+   
+   pWriteURB->complete = WriteSyncCallback;
+   pWriteURB->context = &writeSem;
+
+   // Wake device
+   result = usb_autopm_get_interface( pDev->mpIntf );
+   if (result < 0)
+   {
+      DBG( "unable to resume interface: %d\n", result );
+      
+      // Likely caused by device going from autosuspend -> full suspend
+      if (result == -EPERM)
+      {
+#ifdef CONFIG_PM
+#if (LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,33 ))
+#if (LINUX_VERSION_CODE > KERNEL_VERSION( 2,6,14 ))
+         pDev->mpNetDev->udev->auto_pm = 0;
+#endif
+#endif
+         GobiNetSuspend( pDev->mpIntf, PMSG_SUSPEND );
+#endif /* CONFIG_PM */
+      }
+      usb_free_urb( pWriteURB );
+#if (LINUX_VERSION_CODE > KERNEL_VERSION( 4,12,14 ))
+      kfree( pWriteSetup );
+#endif
+      return result;
+   }
+
+   // Critical section
+   spin_lock_irqsave( &pDev->mQMIDev.mClientMemLock, flags );
+
+   if (AddToURBList( pDev, clientID, pWriteURB ) == false)
+   {
+      usb_free_urb( pWriteURB );
+#if (LINUX_VERSION_CODE > KERNEL_VERSION( 4,12,14 ))
+      kfree( pWriteSetup );
+#endif
+      // End critical section
+      spin_unlock_irqrestore( &pDev->mQMIDev.mClientMemLock, flags );   
+      usb_autopm_put_interface( pDev->mpIntf );
+      return -EINVAL;
+   }
+
+   spin_unlock_irqrestore( &pDev->mQMIDev.mClientMemLock, flags );
+   result = usb_submit_urb( pWriteURB, GFP_KERNEL );
+   //result = usb_submit_urb( pWriteURB, GFP_ATOMIC );
+   spin_lock_irqsave( &pDev->mQMIDev.mClientMemLock, flags );
+
+   if (result < 0)
+   {
+      DBG( "submit URB error %d\n", result );
+      
+      // Get URB back so we can destroy it
+      if (PopFromURBList( pDev, clientID ) != pWriteURB)
+      {
+         // This shouldn't happen
+         DBG( "Didn't get write URB back\n" );
+      }
+
+      usb_free_urb( pWriteURB );
+#if (LINUX_VERSION_CODE > KERNEL_VERSION( 4,12,14 ))
+      kfree( pWriteSetup );
+#endif
+      // End critical section
+      spin_unlock_irqrestore( &pDev->mQMIDev.mClientMemLock, flags );
+      usb_autopm_put_interface( pDev->mpIntf );
+      return result;
+   }
+   
+   // End critical section while we block
+   spin_unlock_irqrestore( &pDev->mQMIDev.mClientMemLock, flags );   
+
+   // Wait for write to finish
+   if (interruptible != 0)
+   {
+      // Allow user interrupts
+      result = down_interruptible( &writeSem );
+   }
+   else
+   {
+      // Ignore user interrupts
+      result = 0;
+      down( &writeSem );
+   }
+
+   // Write is done, release device
+   usb_autopm_put_interface( pDev->mpIntf );
+
+   // Verify device is still valid
+   if (IsDeviceValid( pDev ) == false)
+   {
+      DBG( "Invalid device!\n" );
+
+      usb_free_urb( pWriteURB );
+#if (LINUX_VERSION_CODE > KERNEL_VERSION( 4,12,14 ))
+      kfree( pWriteSetup );
+#endif
+      return -ENXIO;
+   }
+
+   // Restart critical section
+   spin_lock_irqsave( &pDev->mQMIDev.mClientMemLock, flags );
+
+   // Get URB back so we can destroy it
+   if (PopFromURBList( pDev, clientID ) != pWriteURB)
+   {
+      // This shouldn't happen
+      DBG( "Didn't get write URB back\n" );
+   
+      // End critical section
+      spin_unlock_irqrestore( &pDev->mQMIDev.mClientMemLock, flags );
+      usb_free_urb( pWriteURB );
+#if (LINUX_VERSION_CODE > KERNEL_VERSION( 4,12,14 ))
+      kfree( pWriteSetup );
+#endif
+      return -EINVAL;
+   }
+
+   // End critical section
+   spin_unlock_irqrestore( &pDev->mQMIDev.mClientMemLock, flags );   
+
+   if (result == 0)
+   {
+      // Write is finished
+      if (pWriteURB->status == 0)
+      {
+         // Return number of bytes that were supposed to have been written,
+         //   not size of QMI request
+         result = writeBufferSize;
+      }
+      else
+      {
+         DBG( "bad status = %d\n", pWriteURB->status );
+         
+         // Return error value
+         result = pWriteURB->status;
+      }
+   }
+   else
+   {
+      // We have been forcibly interrupted
+      DBG( "Interrupted %d !!!\n", result );
+      DBG( "Device may be in bad state and need reset !!!\n" );
+
+      // URB has not finished
+      usb_kill_urb( pWriteURB );
+   }
+
+   usb_free_urb( pWriteURB );
+#if (LINUX_VERSION_CODE > KERNEL_VERSION( 4,12,14 ))
+   kfree( pWriteSetup );
+#endif
+   return result;
+}
+
+/*=========================================================================*/
+// Internal memory management functions
+/*=========================================================================*/
+
+/*===========================================================================
+METHOD:
+   GetClientID (Public Method)
+
+DESCRIPTION:
+   Request a QMI client for the input service type and initialize memory
+   structure
+
+PARAMETERS:
+   pDev           [ I ] - Device specific memory
+   serviceType    [ I ] - Desired QMI service type
+
+RETURN VALUE:
+   int - Client ID for success (positive)
+         Negative errno for error
+===========================================================================*/
+int GetClientID( 
+   sGobiUSBNet *      pDev,
+   u8                 serviceType )
+{
+   u16 clientID;
+   sClientMemList ** ppClientMem;
+   int result;
+   void * pWriteBuffer;
+   u16 writeBufferSize;
+   void * pReadBuffer;
+   u16 readBufferSize;
+   unsigned long flags;
+   u8 transactionID;
+   
+   if (IsDeviceValid( pDev ) == false)
+   {
+      DBG( "Invalid device!\n" );
+      return -ENXIO;
+   }
+
+   // Run QMI request to be asigned a Client ID
+   if (serviceType != 0)
+   {
+      writeBufferSize = QMICTLGetClientIDReqSize();
+      pWriteBuffer = kmalloc( writeBufferSize, GFP_KERNEL );
+      if (pWriteBuffer == NULL)
+      {
+         return -ENOMEM;
+      }
+
+      transactionID = QMIXactionIDGet( pDev );
+
+      result = QMICTLGetClientIDReq( pWriteBuffer, 
+                                     writeBufferSize,
+                                     transactionID,
+                                     serviceType );
+      if (result < 0)
+      {
+         kfree( pWriteBuffer );
+         return result;
+      }
+
+      
+      result = WriteSync( pDev,
+                          pWriteBuffer,
+                          writeBufferSize,
+                          QMICTL );
+      kfree( pWriteBuffer );
+
+      if (result < 0)
+      {
+         return result;
+      }
+
+      result = ReadSync( pDev,
+                         &pReadBuffer,
+                         QMICTL,
+                         transactionID );
+      if (result < 0)
+      {
+         DBG( "bad read data %d\n", result );
+         return result;
+      }
+      readBufferSize = result;
+
+      result = QMICTLGetClientIDResp( pReadBuffer,
+                                      readBufferSize,
+                                      &clientID );
+
+     /* Upon return from QMICTLGetClientIDResp, clientID
+      * low address contains the Service Number (SN), and
+      * clientID high address contains Client Number (CN)
+      * For the ReadCallback to function correctly,we swap
+      * the SN and CN on a Big Endian architecture.
+      */
+      clientID = le16_to_cpu(clientID);
+
+      kfree( pReadBuffer );
+
+      if (result < 0)
+      {
+         return result;
+      }
+   }
+   else
+   {
+      // QMI CTL will always have client ID 0
+      clientID = 0;
+   }
+
+   // Critical section
+   spin_lock_irqsave( &pDev->mQMIDev.mClientMemLock, flags );
+
+   // Verify client is not already allocated
+   if (FindClientMem( pDev, clientID ) != NULL)
+   {
+      DBG( "Client memory already exists\n" );
+
+      // End Critical section
+      spin_unlock_irqrestore( &pDev->mQMIDev.mClientMemLock, flags );
+      return -ETOOMANYREFS;
+   }
+
+   // Go to last entry in client mem list
+   ppClientMem = &pDev->mQMIDev.mpClientMemList;
+   while (*ppClientMem != NULL)
+   {
+      ppClientMem = &(*ppClientMem)->mpNext;
+   }
+   
+   // Create locations for read to place data into
+   *ppClientMem = kmalloc( sizeof( sClientMemList ), GFP_ATOMIC );
+   if (*ppClientMem == NULL)
+   {
+      DBG( "Error allocating read list\n" );
+
+      // End critical section
+      spin_unlock_irqrestore( &pDev->mQMIDev.mClientMemLock, flags );
+      return -ENOMEM;
+   }
+      
+   (*ppClientMem)->mClientID = clientID;
+   (*ppClientMem)->mpList = NULL;
+   (*ppClientMem)->mpReadNotifyList = NULL;
+   (*ppClientMem)->mpURBList = NULL;
+   (*ppClientMem)->mpNext = NULL;
+
+   // Initialize workqueue for poll()
+   init_waitqueue_head( &(*ppClientMem)->mWaitQueue );
+
+   // End Critical section
+   spin_unlock_irqrestore( &pDev->mQMIDev.mClientMemLock, flags );
+   
+   return (int)( (*ppClientMem)->mClientID );
+}
+
+/*===========================================================================
+METHOD:
+   ReleaseClientID (Public Method)
+
+DESCRIPTION:
+   Release QMI client and free memory
+
+PARAMETERS:
+   pDev           [ I ] - Device specific memory
+   clientID       [ I ] - Requester's client ID
+
+RETURN VALUE:
+   None
+===========================================================================*/
+void ReleaseClientID(
+   sGobiUSBNet *    pDev,
+   u16                clientID )
+{
+   int result;
+   sClientMemList ** ppDelClientMem;
+   sClientMemList * pNextClientMem;
+   struct urb * pDelURB;
+   void * pDelData;
+   u16 dataSize;
+   void * pWriteBuffer;
+   u16 writeBufferSize;
+   void * pReadBuffer;
+   u16 readBufferSize;
+   unsigned long flags;
+   u8 transactionID;
+
+   // Is device is still valid?
+   if (IsDeviceValid( pDev ) == false)
+   {
+      DBG( "invalid device\n" );
+      return;
+   }
+   
+   DBG( "releasing 0x%04X\n", clientID );
+
+   // Run QMI ReleaseClientID if this isn't QMICTL   
+   if (clientID != QMICTL)
+   {
+      // Note: all errors are non fatal, as we always want to delete 
+      //    client memory in latter part of function
+      
+      writeBufferSize = QMICTLReleaseClientIDReqSize();
+      pWriteBuffer = kmalloc( writeBufferSize, GFP_KERNEL );
+      if (pWriteBuffer == NULL)
+      {
+         DBG( "memory error\n" );
+      }
+      else
+      {
+         transactionID = QMIXactionIDGet( pDev );
+
+         result = QMICTLReleaseClientIDReq( pWriteBuffer, 
+                                            writeBufferSize,
+                                            transactionID,
+                                            clientID );
+         if (result < 0)
+         {
+            kfree( pWriteBuffer );
+            DBG( "error %d filling req buffer\n", result );
+         }
+         else
+         {
+            result = WriteSync( pDev,
+                                pWriteBuffer,
+                                writeBufferSize,
+                                QMICTL );
+            kfree( pWriteBuffer );
+
+            if (result < 0)
+            {
+               DBG( "bad write status %d\n", result );
+            }
+            else
+            {
+               result = ReadSync( pDev,
+                                  &pReadBuffer,
+                                  QMICTL,
+                                  transactionID );
+               if (result < 0)
+               {
+                  DBG( "bad read status %d\n", result );
+               }
+               else
+               {
+                  readBufferSize = result;
+
+                  result = QMICTLReleaseClientIDResp( pReadBuffer,
+                                                      readBufferSize );
+                  kfree( pReadBuffer );
+
+                  if (result < 0)
+                  {
+                     DBG( "error %d parsing response\n", result );
+                  }
+               }
+            }
+         }
+      }
+   }
+
+   // Cleaning up client memory
+   
+   // Critical section
+   spin_lock_irqsave( &pDev->mQMIDev.mClientMemLock, flags );
+
+   // Can't use FindClientMem, I need to keep pointer of previous
+   ppDelClientMem = &pDev->mQMIDev.mpClientMemList;
+   while (*ppDelClientMem != NULL)
+   {
+      if ((*ppDelClientMem)->mClientID == clientID)
+      {
+         pNextClientMem = (*ppDelClientMem)->mpNext;
+
+         // Notify all clients
+         while (NotifyAndPopNotifyList( pDev,
+                                        clientID,
+                                        0 ) == true );         
+
+         // Kill and free all URB's
+         pDelURB = PopFromURBList( pDev, clientID );
+         while (pDelURB != NULL)
+         {
+            usb_kill_urb( pDelURB );
+            usb_free_urb( pDelURB );
+            pDelURB = PopFromURBList( pDev, clientID );
+         }
+
+         // Free any unread data
+         while (PopFromReadMemList( pDev, 
+                                    clientID,
+                                    0,
+                                    &pDelData,
+                                    &dataSize ) == true )
+         {
+            kfree( pDelData );
+         }
+
+         // Delete client Mem
+         if (!waitqueue_active( &(*ppDelClientMem)->mWaitQueue))
+         kfree( *ppDelClientMem );
+         else
+            DBG("memory leak!\n");
+
+         // Overwrite the pointer that was to this client mem
+         *ppDelClientMem = pNextClientMem;
+      }
+      else
+      {
+         // I now point to (a pointer of ((the node I was at)'s mpNext))
+         ppDelClientMem = &(*ppDelClientMem)->mpNext;
+      }
+   }
+   
+   // End Critical section
+   spin_unlock_irqrestore( &pDev->mQMIDev.mClientMemLock, flags );
+
+   return;
+}
+
+/*===========================================================================
+METHOD:
+   FindClientMem (Public Method)
+
+DESCRIPTION:
+   Find this client's memory
+
+   Caller MUST have lock on mClientMemLock
+
+PARAMETERS:
+   pDev           [ I ] - Device specific memory
+   clientID       [ I ] - Requester's client ID
+
+RETURN VALUE:
+   sClientMemList - Pointer to requested sClientMemList for success
+                    NULL for error
+===========================================================================*/
+sClientMemList * FindClientMem( 
+   sGobiUSBNet *      pDev,
+   u16              clientID )
+{
+   sClientMemList * pClientMem;
+   
+   if (IsDeviceValid( pDev ) == false)
+   {
+      DBG( "Invalid device\n" );
+      return NULL;
+   }
+   
+#ifdef CONFIG_SMP
+   // Verify Lock
+   if (spin_is_locked( &pDev->mQMIDev.mClientMemLock ) == 0)
+   {
+      DBG( "unlocked\n" );
+      BUG();
+   }
+#endif
+   
+   pClientMem = pDev->mQMIDev.mpClientMemList;
+   while (pClientMem != NULL)
+   {
+      if (pClientMem->mClientID == clientID)
+      {
+         // Success
+         VDBG("Found client's 0x%x memory\n", clientID);
+         return pClientMem;
+      }
+      
+      pClientMem = pClientMem->mpNext;
+   }
+
+   DBG( "Could not find client mem 0x%04X\n", clientID );
+   return NULL;
+}
+
+/*===========================================================================
+METHOD:
+   AddToReadMemList (Public Method)
+
+DESCRIPTION:
+   Add Data to this client's ReadMem list
+   
+   Caller MUST have lock on mClientMemLock
+
+PARAMETERS:
+   pDev           [ I ] - Device specific memory
+   clientID       [ I ] - Requester's client ID
+   transactionID  [ I ] - Transaction ID or 0 for any
+   pData          [ I ] - Data to add
+   dataSize       [ I ] - Size of data to add
+
+RETURN VALUE:
+   bool
+===========================================================================*/
+bool AddToReadMemList( 
+   sGobiUSBNet *      pDev,
+   u16              clientID,
+   u16              transactionID,
+   void *           pData,
+   u16              dataSize )
+{
+   sClientMemList * pClientMem;
+   sReadMemList ** ppThisReadMemList;
+
+#ifdef CONFIG_SMP
+   // Verify Lock
+   if (spin_is_locked( &pDev->mQMIDev.mClientMemLock ) == 0)
+   {
+      DBG( "unlocked\n" );
+      BUG();
+   }
+#endif
+
+   // Get this client's memory location
+   pClientMem = FindClientMem( pDev, clientID );
+   if (pClientMem == NULL)
+   {
+      DBG( "Could not find this client's memory 0x%04X\n",
+           clientID );
+
+      return false;
+   }
+
+   // Go to last ReadMemList entry
+   ppThisReadMemList = &pClientMem->mpList;
+   while (*ppThisReadMemList != NULL)
+   {
+      ppThisReadMemList = &(*ppThisReadMemList)->mpNext;
+   }
+   
+   *ppThisReadMemList = kmalloc( sizeof( sReadMemList ), GFP_ATOMIC );
+   if (*ppThisReadMemList == NULL)
+   {
+      DBG( "Mem error\n" );
+
+      return false;
+   }   
+   
+   (*ppThisReadMemList)->mpNext = NULL;
+   (*ppThisReadMemList)->mpData = pData;
+   (*ppThisReadMemList)->mDataSize = dataSize;
+   (*ppThisReadMemList)->mTransactionID = transactionID;
+   
+   return true;
+}
+
+/*===========================================================================
+METHOD:
+   PopFromReadMemList (Public Method)
+
+DESCRIPTION:
+   Remove data from this client's ReadMem list if it matches 
+   the specified transaction ID.
+   
+   Caller MUST have lock on mClientMemLock
+
+PARAMETERS:
+   pDev              [ I ] - Device specific memory
+   clientID          [ I ] - Requester's client ID
+   transactionID     [ I ] - Transaction ID or 0 for any
+   ppData            [I/O] - On success, will be filled with a 
+                             pointer to read buffer
+   pDataSize         [I/O] - On succces, will be filled with the 
+                             read buffer's size
+
+RETURN VALUE:
+   bool
+===========================================================================*/
+bool PopFromReadMemList( 
+   sGobiUSBNet *      pDev,
+   u16                  clientID,
+   u16                  transactionID,
+   void **              ppData,
+   u16 *                pDataSize )
+{
+   sClientMemList * pClientMem;
+   sReadMemList * pDelReadMemList, ** ppReadMemList;
+
+#ifdef CONFIG_SMP
+   // Verify Lock
+   if (spin_is_locked( &pDev->mQMIDev.mClientMemLock ) == 0)
+   {
+      DBG( "unlocked\n" );
+      BUG();
+   }
+#endif
+
+   // Get this client's memory location
+   pClientMem = FindClientMem( pDev, clientID );
+   if (pClientMem == NULL)
+   {
+      DBG( "Could not find this client's memory 0x%04X\n",
+           clientID );
+
+      return false;
+   }
+   
+   ppReadMemList = &(pClientMem->mpList);
+   pDelReadMemList = NULL;
+   
+   // Find first message that matches this transaction ID
+   while (*ppReadMemList != NULL)
+   {
+      // Do we care about transaction ID?
+      if (transactionID == 0
+      ||  transactionID == (*ppReadMemList)->mTransactionID )
+      {
+         pDelReadMemList = *ppReadMemList;
+         VDBG(  "*ppReadMemList = 0x%p pDelReadMemList = 0x%p\n",
+               *ppReadMemList, pDelReadMemList );
+         break;
+      }
+      
+      VDBG( "skipping 0x%04X data TID = %x\n", clientID, (*ppReadMemList)->mTransactionID );
+      
+      // Next
+      ppReadMemList = &(*ppReadMemList)->mpNext;
+   }
+   VDBG(  "*ppReadMemList = 0x%p pDelReadMemList = 0x%p\n",
+         *ppReadMemList, pDelReadMemList );
+   if (pDelReadMemList != NULL)
+   {
+      *ppReadMemList = (*ppReadMemList)->mpNext;
+      
+      // Copy to output
+      *ppData = pDelReadMemList->mpData;
+      *pDataSize = pDelReadMemList->mDataSize;
+      VDBG(  "*ppData = 0x%p pDataSize = %u\n",
+            *ppData, *pDataSize );
+      
+      // Free memory
+      kfree( pDelReadMemList );
+      
+      return true;
+   }
+   else
+   {
+      DBG( "No read memory to pop, Client 0x%04X, TID = %x\n", 
+           clientID, 
+           transactionID );
+      return false;
+   }
+}
+
+/*===========================================================================
+METHOD:
+   AddToNotifyList (Public Method)
+
+DESCRIPTION:
+   Add Notify entry to this client's notify List
+   
+   Caller MUST have lock on mClientMemLock
+
+PARAMETERS:
+   pDev              [ I ] - Device specific memory
+   clientID          [ I ] - Requester's client ID
+   transactionID     [ I ] - Transaction ID or 0 for any
+   pNotifyFunct      [ I ] - Callback function to be run when data is available
+   pData             [ I ] - Data buffer that willl be passed (unmodified) 
+                             to callback
+
+RETURN VALUE:
+   bool
+===========================================================================*/
+bool AddToNotifyList( 
+   sGobiUSBNet *      pDev,
+   u16                  clientID,
+   u16                  transactionID,
+   void                 (* pNotifyFunct)(sGobiUSBNet *, u16, void *),
+   void *               pData )
+{
+   sClientMemList * pClientMem;
+   sNotifyList ** ppThisNotifyList;
+
+#ifdef CONFIG_SMP
+   // Verify Lock
+   if (spin_is_locked( &pDev->mQMIDev.mClientMemLock ) == 0)
+   {
+      DBG( "unlocked\n" );
+      BUG();
+   }
+#endif
+
+   // Get this client's memory location
+   pClientMem = FindClientMem( pDev, clientID );
+   if (pClientMem == NULL)
+   {
+      DBG( "Could not find this client's memory 0x%04X\n", clientID );
+      return false;
+   }
+
+   // Go to last URBList entry
+   ppThisNotifyList = &pClientMem->mpReadNotifyList;
+   while (*ppThisNotifyList != NULL)
+   {
+      ppThisNotifyList = &(*ppThisNotifyList)->mpNext;
+   }
+   
+   *ppThisNotifyList = kmalloc( sizeof( sNotifyList ), GFP_ATOMIC );
+   if (*ppThisNotifyList == NULL)
+   {
+      DBG( "Mem error\n" );
+      return false;
+   }   
+   
+   (*ppThisNotifyList)->mpNext = NULL;
+   (*ppThisNotifyList)->mpNotifyFunct = pNotifyFunct;
+   (*ppThisNotifyList)->mpData = pData;
+   (*ppThisNotifyList)->mTransactionID = transactionID;
+   
+   return true;
+}
+
+/*===========================================================================
+METHOD:
+   NotifyAndPopNotifyList (Public Method)
+
+DESCRIPTION:
+   Remove first Notify entry from this client's notify list 
+   and Run function
+   
+   Caller MUST have lock on mClientMemLock
+
+PARAMETERS:
+   pDev              [ I ] - Device specific memory
+   clientID          [ I ] - Requester's client ID
+   transactionID     [ I ] - Transaction ID or 0 for any
+
+RETURN VALUE:
+   bool
+===========================================================================*/
+bool NotifyAndPopNotifyList( 
+   sGobiUSBNet *        pDev,
+   u16                  clientID,
+   u16                  transactionID )
+{
+   sClientMemList * pClientMem;
+   sNotifyList * pDelNotifyList, ** ppNotifyList;
+
+#ifdef CONFIG_SMP
+   // Verify Lock
+   if (spin_is_locked( &pDev->mQMIDev.mClientMemLock ) == 0)
+   {
+      DBG( "unlocked\n" );
+      BUG();
+   }
+#endif
+
+   // Get this client's memory location
+   pClientMem = FindClientMem( pDev, clientID );
+   if (pClientMem == NULL)
+   {
+      DBG( "Could not find this client's memory 0x%04X\n", clientID );
+      return false;
+   }
+
+   ppNotifyList = &(pClientMem->mpReadNotifyList);
+   pDelNotifyList = NULL;
+
+   // Remove from list
+   while (*ppNotifyList != NULL)
+   {
+      // Do we care about transaction ID?
+      if (transactionID == 0
+      ||  (*ppNotifyList)->mTransactionID == 0
+      ||  transactionID == (*ppNotifyList)->mTransactionID)
+      {
+         pDelNotifyList = *ppNotifyList;
+         break;
+      }
+      
+      DBG( "skipping data TID = %x\n", (*ppNotifyList)->mTransactionID );
+      
+      // next
+      ppNotifyList = &(*ppNotifyList)->mpNext;
+   }
+   
+   if (pDelNotifyList != NULL)
+   {
+      // Remove element
+      *ppNotifyList = (*ppNotifyList)->mpNext;
+      
+      // Run notification function
+      if (pDelNotifyList->mpNotifyFunct != NULL)
+      {
+         // Unlock for callback
+         spin_unlock( &pDev->mQMIDev.mClientMemLock );
+      
+         pDelNotifyList->mpNotifyFunct( pDev,
+                                        clientID,
+                                        pDelNotifyList->mpData );
+
+         // Restore lock
+         spin_lock( &pDev->mQMIDev.mClientMemLock );
+      }
+      
+      // Delete memory
+      kfree( pDelNotifyList );
+
+      return true;
+   }
+   else
+   {
+      DBG( "no one to notify for TID %x\n", transactionID );
+      
+      return false;
+   }
+}
+
+/*===========================================================================
+METHOD:
+   AddToURBList (Public Method)
+
+DESCRIPTION:
+   Add URB to this client's URB list
+   
+   Caller MUST have lock on mClientMemLock
+
+PARAMETERS:
+   pDev              [ I ] - Device specific memory
+   clientID          [ I ] - Requester's client ID
+   pURB              [ I ] - URB to be added
+
+RETURN VALUE:
+   bool
+===========================================================================*/
+bool AddToURBList( 
+   sGobiUSBNet *      pDev,
+   u16                  clientID,
+   struct urb *     pURB )
+{
+   sClientMemList * pClientMem;
+   sURBList ** ppThisURBList;
+
+#ifdef CONFIG_SMP
+   // Verify Lock
+   if (spin_is_locked( &pDev->mQMIDev.mClientMemLock ) == 0)
+   {
+      DBG( "unlocked\n" );
+      BUG();
+   }
+#endif
+
+   // Get this client's memory location
+   pClientMem = FindClientMem( pDev, clientID );
+   if (pClientMem == NULL)
+   {
+      DBG( "Could not find this client's memory 0x%04X\n", clientID );
+      return false;
+   }
+
+   // Go to last URBList entry
+   ppThisURBList = &pClientMem->mpURBList;
+   while (*ppThisURBList != NULL)
+   {
+      ppThisURBList = &(*ppThisURBList)->mpNext;
+   }
+   
+   *ppThisURBList = kmalloc( sizeof( sURBList ), GFP_ATOMIC );
+   if (*ppThisURBList == NULL)
+   {
+      DBG( "Mem error\n" );
+      return false;
+   }   
+   
+   (*ppThisURBList)->mpNext = NULL;
+   (*ppThisURBList)->mpURB = pURB;
+   
+   return true;
+}
+
+/*===========================================================================
+METHOD:
+   PopFromURBList (Public Method)
+
+DESCRIPTION:
+   Remove URB from this client's URB list
+   
+   Caller MUST have lock on mClientMemLock
+
+PARAMETERS:
+   pDev           [ I ] - Device specific memory
+   clientID       [ I ] - Requester's client ID
+
+RETURN VALUE:
+   struct urb - Pointer to requested client's URB
+                NULL for error
+===========================================================================*/
+struct urb * PopFromURBList( 
+   sGobiUSBNet *      pDev,
+   u16                  clientID )
+{
+   sClientMemList * pClientMem;
+   sURBList * pDelURBList;
+   struct urb * pURB;
+
+#ifdef CONFIG_SMP
+   // Verify Lock
+   if (spin_is_locked( &pDev->mQMIDev.mClientMemLock ) == 0)
+   {
+      DBG( "unlocked\n" );
+      BUG();
+   }
+#endif
+
+   // Get this client's memory location
+   pClientMem = FindClientMem( pDev, clientID );
+   if (pClientMem == NULL)
+   {
+      DBG( "Could not find this client's memory 0x%04X\n", clientID );
+      return NULL;
+   }
+
+   // Remove from list
+   if (pClientMem->mpURBList != NULL)
+   {
+      pDelURBList = pClientMem->mpURBList;
+      pClientMem->mpURBList = pClientMem->mpURBList->mpNext;
+      
+      // Copy to output
+      pURB = pDelURBList->mpURB;
+      
+      // Delete memory
+      kfree( pDelURBList );
+
+      return pURB;
+   }
+   else
+   {
+      DBG( "No URB's to pop\n" );
+      
+      return NULL;
+   }
+}
+
+#ifndef f_dentry
+#define f_dentry f_path.dentry
+#endif
+
+/*=========================================================================*/
+// Internal userspace wrappers
+/*=========================================================================*/
+
+/*===========================================================================
+METHOD:
+   UserspaceunlockedIOCTL (Public Method)
+
+DESCRIPTION:
+   Internal wrapper for Userspace IOCTL interface
+
+PARAMETERS
+   pFilp        [ I ] - userspace file descriptor
+   cmd          [ I ] - IOCTL command
+   arg          [ I ] - IOCTL argument
+
+RETURN VALUE:
+   long - 0 for success
+         Negative errno for failure
+===========================================================================*/
+long UserspaceunlockedIOCTL(
+   struct file *     pFilp,
+   unsigned int      cmd, 
+   unsigned long     arg )
+{
+   int result;
+   u32 devVIDPID;
+
+   sQMIFilpStorage * pFilpData = (sQMIFilpStorage *)pFilp->private_data;
+
+   if (pFilpData == NULL)
+   {
+      DBG( "Bad file data\n" );
+      return -EBADF;
+   }
+   
+   if (IsDeviceValid( pFilpData->mpDev ) == false)
+   {
+      DBG( "Invalid device! Updating f_ops\n" );
+      pFilp->f_op = pFilp->f_dentry->d_inode->i_fop;
+      return -ENXIO;
+   }
+
+   switch (cmd)
+   {
+      case IOCTL_QMI_GET_SERVICE_FILE:    
+         DBG( "Setting up QMI for service %lu\n", arg );
+         if ((u8)arg == 0)
+         {
+            DBG( "Cannot use QMICTL from userspace\n" );
+            return -EINVAL;
+         }
+
+         // Connection is already setup
+         if (pFilpData->mClientID != (u16)-1)
+         {
+            DBG( "Close the current connection before opening a new one\n" );
+            return -EBADR;
+         }
+         
+         result = GetClientID( pFilpData->mpDev, (u8)arg );
+// it seems QMIWDA only allow one client, if the last CM donot realese it (killed by SIGKILL).
+// can force release it at here
+#if 1
+         if (result < 0 && (u8)arg == QMIWDA)
+         {
+             ReleaseClientID( pFilpData->mpDev, QMIWDA | (1 << 8) );
+             result = GetClientID( pFilpData->mpDev, (u8)arg );
+         }
+#endif
+         if (result < 0)
+         {
+            return result;
+         }
+         pFilpData->mClientID = (u16)result;
+         DBG("pFilpData->mClientID = 0x%x\n", pFilpData->mClientID );
+         return 0;
+         break;
+
+
+      case IOCTL_QMI_GET_DEVICE_VIDPID:
+         if (arg == 0)
+         {
+            DBG( "Bad VIDPID buffer\n" );
+            return -EINVAL;
+         }
+         
+         // Extra verification
+         if (pFilpData->mpDev->mpNetDev == 0)
+         {
+            DBG( "Bad mpNetDev\n" );
+            return -ENOMEM;
+         }
+         if (pFilpData->mpDev->mpNetDev->udev == 0)
+         {
+            DBG( "Bad udev\n" );
+            return -ENOMEM;
+         }
+
+         devVIDPID = ((le16_to_cpu( pFilpData->mpDev->mpNetDev->udev->descriptor.idVendor ) << 16)
+                     + le16_to_cpu( pFilpData->mpDev->mpNetDev->udev->descriptor.idProduct ) );
+
+         result = copy_to_user( (unsigned int *)arg, &devVIDPID, 4 );
+         if (result != 0)
+         {
+            DBG( "Copy to userspace failure %d\n", result );
+         }
+
+         return result;
+                 
+         break;
+
+      case IOCTL_QMI_GET_DEVICE_MEID:
+         if (arg == 0)
+         {
+            DBG( "Bad MEID buffer\n" );
+            return -EINVAL;
+         }
+         
+         result = copy_to_user( (unsigned int *)arg, &pFilpData->mpDev->mMEID[0], 14 );
+         if (result != 0)
+         {
+            DBG( "Copy to userspace failure %d\n", result );
+         }
+
+         return result;
+                 
+         break;
+         
+      default:
+         return -EBADRQC;       
+   }
+}
+
+/*=========================================================================*/
+// Userspace wrappers
+/*=========================================================================*/
+
+/*===========================================================================
+METHOD:
+   UserspaceOpen (Public Method)
+
+DESCRIPTION:
+   Userspace open
+      IOCTL must be called before reads or writes
+
+PARAMETERS
+   pInode       [ I ] - kernel file descriptor
+   pFilp        [ I ] - userspace file descriptor
+
+RETURN VALUE:
+   int - 0 for success
+         Negative errno for failure
+===========================================================================*/
+int UserspaceOpen(
+   struct inode *         pInode,
+   struct file *          pFilp )
+{
+   sQMIFilpStorage * pFilpData;
+
+   // Optain device pointer from pInode
+   sQMIDev * pQMIDev = container_of( pInode->i_cdev,
+                                     sQMIDev,
+                                     mCdev );
+   sGobiUSBNet * pDev = container_of( pQMIDev,
+                                    sGobiUSBNet,
+                                    mQMIDev );
+
+   if ((pDev->mpNetDev->udev->descriptor.idVendor == cpu_to_le16(0x2CB7)) ||
+       (pDev->mpNetDev->udev->descriptor.idVendor == cpu_to_le16(0x05C6)) ||
+       (pDev->mpNetDev->udev->descriptor.idVendor == cpu_to_le16(0x1508)))
+   {
+      atomic_inc(&pDev->refcount);
+      if (!pDev->mbQMIReady) {
+         if (wait_for_completion_interruptible_timeout(&pDev->mQMIReadyCompletion, 15*HZ) <= 0) {
+            if (atomic_dec_and_test(&pDev->refcount)) {
+               kfree( pDev );
+            }
+            return -ETIMEDOUT;
+         }
+      }
+      atomic_dec(&pDev->refcount);
+   }
+
+   if (IsDeviceValid( pDev ) == false)
+   {
+      DBG( "Invalid device\n" );
+      return -ENXIO;
+   }
+
+   // Setup data in pFilp->private_data
+   pFilp->private_data = kmalloc( sizeof( sQMIFilpStorage ), GFP_KERNEL );
+   if (pFilp->private_data == NULL)
+   {
+      DBG( "Mem error\n" );
+      return -ENOMEM;
+   }
+
+   pFilpData = (sQMIFilpStorage *)pFilp->private_data;
+   pFilpData->mClientID = (u16)-1;
+   atomic_inc(&pDev->refcount);
+   pFilpData->mpDev = pDev;
+
+   return 0;
+}
+
+/*===========================================================================
+METHOD:
+   UserspaceIOCTL (Public Method)
+
+DESCRIPTION:
+   Userspace IOCTL functions
+
+PARAMETERS
+   pUnusedInode [ I ] - (unused) kernel file descriptor
+   pFilp        [ I ] - userspace file descriptor
+   cmd          [ I ] - IOCTL command
+   arg          [ I ] - IOCTL argument
+
+RETURN VALUE:
+   int - 0 for success
+         Negative errno for failure
+===========================================================================*/
+int UserspaceIOCTL(
+   struct inode *    pUnusedInode,
+   struct file *     pFilp,
+   unsigned int      cmd,
+   unsigned long     arg ) 
+{
+   // call the internal wrapper function
+   return (int)UserspaceunlockedIOCTL( pFilp, cmd, arg );  
+}
+
+/*===========================================================================
+METHOD:
+   UserspaceClose (Public Method)
+
+DESCRIPTION:
+   Userspace close
+      Release client ID and free memory
+
+PARAMETERS
+   pFilp           [ I ] - userspace file descriptor
+   unusedFileTable [ I ] - (unused) file table
+
+RETURN VALUE:
+   int - 0 for success
+         Negative errno for failure
+===========================================================================*/
+#if (LINUX_VERSION_CODE > KERNEL_VERSION( 2,6,14 ))
+int UserspaceClose( 
+   struct file *       pFilp,
+   fl_owner_t          unusedFileTable )
+#else
+int UserspaceClose( struct file *       pFilp )
+#endif
+{
+   sQMIFilpStorage * pFilpData = (sQMIFilpStorage *)pFilp->private_data;
+   struct task_struct * pEachTask;
+   struct fdtable * pFDT;
+   int count = 0;
+   int used = 0;
+   unsigned long flags;
+
+   if (pFilpData == NULL)
+   {
+      DBG( "bad file data\n" );
+      return -EBADF;
+   }
+
+   // Fallthough.  If f_count == 1 no need to do more checks
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION( 2,6,24 ))
+   if (atomic_read( &pFilp->f_count ) != 1)
+#else
+   if (atomic_long_read( &pFilp->f_count ) != 1)
+#endif
+   {
+      rcu_read_lock();
+      for_each_process( pEachTask )
+      {
+         task_lock(pEachTask);
+         if (pEachTask == NULL || pEachTask->files == NULL)
+         {
+            // Some tasks may not have files (e.g. Xsession)
+            task_unlock(pEachTask);
+            continue;
+         }
+         spin_lock_irqsave( &pEachTask->files->file_lock, flags );
+         task_unlock(pEachTask); //kernel/exit.c:do_exit() -> fs/file.c:exit_files()
+         pFDT = files_fdtable( pEachTask->files );
+         for (count = 0; count < pFDT->max_fds; count++)
+         {
+            // Before this function was called, this file was removed
+            // from our task's file table so if we find it in a file
+            // table then it is being used by another task
+            if (pFDT->fd[count] == pFilp)
+            {
+               used++;
+               break;
+            }
+         }
+         spin_unlock_irqrestore( &pEachTask->files->file_lock, flags );
+      }
+      rcu_read_unlock();
+      
+      if (used > 0)
+      {
+         DBG( "not closing, as this FD is open by %d other process\n", used );
+         return 0;
+      }
+   }
+
+   if (IsDeviceValid( pFilpData->mpDev ) == false)
+   {
+      DBG( "Invalid device! Updating f_ops\n" );
+      pFilp->f_op = pFilp->f_dentry->d_inode->i_fop;
+      return -ENXIO;
+   }
+   
+   DBG( "0x%04X\n", pFilpData->mClientID );
+   
+   // Disable pFilpData so they can't keep sending read or write 
+   //    should this function hang
+   // Note: memory pointer is still saved in pFilpData to be deleted later
+   pFilp->private_data = NULL;
+
+   if (pFilpData->mClientID != (u16)-1)
+   {
+      if (pFilpData->mpDev->mbDeregisterQMIDevice)
+         pFilpData->mClientID = (u16)-1; //DeregisterQMIDevice() will release this ClientID
+      else
+      ReleaseClientID( pFilpData->mpDev,
+                       pFilpData->mClientID );
+   }
+   atomic_dec(&pFilpData->mpDev->refcount);
+      
+   kfree( pFilpData );
+   return 0;
+}
+
+/*===========================================================================
+METHOD:
+   UserspaceRead (Public Method)
+
+DESCRIPTION:
+   Userspace read (synchronous)
+
+PARAMETERS
+   pFilp           [ I ] - userspace file descriptor
+   pBuf            [ I ] - read buffer
+   size            [ I ] - size of read buffer
+   pUnusedFpos     [ I ] - (unused) file position
+
+RETURN VALUE:
+   ssize_t - Number of bytes read for success
+             Negative errno for failure
+===========================================================================*/
+ssize_t UserspaceRead( 
+   struct file *          pFilp,
+   char __user *          pBuf, 
+   size_t                 size,
+   loff_t *               pUnusedFpos )
+{
+   int result;
+   void * pReadData = NULL;
+   void * pSmallReadData;
+   sQMIFilpStorage * pFilpData = (sQMIFilpStorage *)pFilp->private_data;
+
+   if (pFilpData == NULL)
+   {
+      DBG( "Bad file data\n" );
+      return -EBADF;
+   }
+
+   if (IsDeviceValid( pFilpData->mpDev ) == false)
+   {
+      DBG( "Invalid device! Updating f_ops\n" );
+      pFilp->f_op = pFilp->f_dentry->d_inode->i_fop;
+      return -ENXIO;
+   }
+   
+   if (pFilpData->mClientID == (u16)-1)
+   {
+      DBG( "Client ID must be set before reading 0x%04X\n",
+           pFilpData->mClientID );
+      return -EBADR;
+   }
+   
+   // Perform synchronous read
+   result = ReadSync( pFilpData->mpDev,
+                      &pReadData,
+                      pFilpData->mClientID,
+                      0 );
+   if (result <= 0)
+   {
+      return result;
+   }
+   
+   // Discard QMUX header
+   result -= QMUXHeaderSize();
+   pSmallReadData = pReadData + QMUXHeaderSize();
+
+   if (result > size)
+   {
+      DBG( "Read data is too large for amount user has requested\n" );
+      kfree( pReadData );
+      return -EOVERFLOW;
+   }
+
+   DBG(  "pBuf = 0x%p pSmallReadData = 0x%p, result = %d",
+         pBuf, pSmallReadData, result );
+
+   if (copy_to_user( pBuf, pSmallReadData, result ) != 0)
+   {
+      DBG( "Error copying read data to user\n" );
+      result = -EFAULT;
+   }
+   
+   // Reader is responsible for freeing read buffer
+   kfree( pReadData );
+   
+   return result;
+}
+
+/*===========================================================================
+METHOD:
+   UserspaceWrite (Public Method)
+
+DESCRIPTION:
+   Userspace write (synchronous)
+
+PARAMETERS
+   pFilp           [ I ] - userspace file descriptor
+   pBuf            [ I ] - write buffer
+   size            [ I ] - size of write buffer
+   pUnusedFpos     [ I ] - (unused) file position
+
+RETURN VALUE:
+   ssize_t - Number of bytes read for success
+             Negative errno for failure
+===========================================================================*/
+ssize_t UserspaceWrite(
+   struct file *        pFilp, 
+   const char __user *  pBuf, 
+   size_t               size,
+   loff_t *             pUnusedFpos )
+{
+   int status;
+   void * pWriteBuffer;
+   sQMIFilpStorage * pFilpData = (sQMIFilpStorage *)pFilp->private_data;
+
+   if (pFilpData == NULL)
+   {
+      DBG( "Bad file data\n" );
+      return -EBADF;
+   }
+
+   if (IsDeviceValid( pFilpData->mpDev ) == false)
+   {
+      DBG( "Invalid device! Updating f_ops\n" );
+      pFilp->f_op = pFilp->f_dentry->d_inode->i_fop;
+      return -ENXIO;
+   }
+
+   if (pFilpData->mClientID == (u16)-1)
+   {
+      DBG( "Client ID must be set before writing 0x%04X\n",
+           pFilpData->mClientID );
+      return -EBADR;
+   }
+   
+   // Copy data from user to kernel space
+   pWriteBuffer = kmalloc( size + QMUXHeaderSize(), GFP_KERNEL );
+   if (pWriteBuffer == NULL)
+   {
+      return -ENOMEM;
+   }
+   status = copy_from_user( pWriteBuffer + QMUXHeaderSize(), pBuf, size );
+   if (status != 0)
+   {
+      DBG( "Unable to copy data from userspace %d\n", status );
+      kfree( pWriteBuffer );
+      return status;
+   }
+
+   status = WriteSync( pFilpData->mpDev,
+                       pWriteBuffer, 
+                       size + QMUXHeaderSize(),
+                       pFilpData->mClientID );
+
+   kfree( pWriteBuffer );
+   
+   // On success, return requested size, not full QMI reqest size
+   if (status == size + QMUXHeaderSize())
+   {
+      return size;
+   }
+   else
+   {
+      return status;
+   }
+}
+
+/*===========================================================================
+METHOD:
+   UserspacePoll (Public Method)
+
+DESCRIPTION:
+   Used to determine if read/write operations are possible without blocking
+
+PARAMETERS
+   pFilp              [ I ] - userspace file descriptor
+   pPollTable         [I/O] - Wait object to notify the kernel when data 
+                              is ready
+
+RETURN VALUE:
+   unsigned int - bitmask of what operations can be done immediately
+===========================================================================*/
+unsigned int UserspacePoll(
+   struct file *                  pFilp,
+   struct poll_table_struct *     pPollTable )
+{
+   sQMIFilpStorage * pFilpData = (sQMIFilpStorage *)pFilp->private_data;
+   sClientMemList * pClientMem;
+   unsigned long flags;
+
+   // Always ready to write
+   unsigned long status = POLLOUT | POLLWRNORM;
+
+   if (pFilpData == NULL)
+   {
+      DBG( "Bad file data\n" );
+      return POLLERR;
+   }
+
+   if (IsDeviceValid( pFilpData->mpDev ) == false)
+   {
+      DBG( "Invalid device! Updating f_ops\n" );
+      pFilp->f_op = pFilp->f_dentry->d_inode->i_fop;
+      return POLLERR;
+   }
+
+   if (pFilpData->mpDev->mbDeregisterQMIDevice)
+   {
+      DBG( "DeregisterQMIDevice ing\n" );
+      return POLLHUP | POLLERR;
+   }
+
+   if (pFilpData->mClientID == (u16)-1)
+   {
+      DBG( "Client ID must be set before polling 0x%04X\n",
+           pFilpData->mClientID );
+      return POLLERR;
+   }
+
+   // Critical section
+   spin_lock_irqsave( &pFilpData->mpDev->mQMIDev.mClientMemLock, flags );
+
+   // Get this client's memory location
+   pClientMem = FindClientMem( pFilpData->mpDev, 
+                               pFilpData->mClientID );
+   if (pClientMem == NULL)
+   {
+      DBG( "Could not find this client's memory 0x%04X\n",
+           pFilpData->mClientID );
+
+      spin_unlock_irqrestore( &pFilpData->mpDev->mQMIDev.mClientMemLock, 
+                              flags );
+      return POLLERR;
+   }
+   
+   poll_wait( pFilp, &pClientMem->mWaitQueue, pPollTable );
+
+   if (pClientMem->mpList != NULL)
+   {
+      status |= POLLIN | POLLRDNORM;
+   }
+
+   // End critical section
+   spin_unlock_irqrestore( &pFilpData->mpDev->mQMIDev.mClientMemLock, flags );
+
+   // Always ready to write 
+   return (status | POLLOUT | POLLWRNORM);
+}
+
+/*=========================================================================*/
+// Initializer and destructor
+/*=========================================================================*/
+int QMICTLSyncProc(sGobiUSBNet *pDev)
+{
+   void *pWriteBuffer;
+   void *pReadBuffer;
+   int result;
+   u16 writeBufferSize;
+   u16 readBufferSize;
+   u8 transactionID;
+   unsigned long flags;
+
+   if (IsDeviceValid( pDev ) == false)
+   {
+      DBG( "Invalid device\n" );
+      return -EFAULT;
+   }
+
+   writeBufferSize= QMICTLSyncReqSize();
+   pWriteBuffer = kmalloc( writeBufferSize, GFP_KERNEL );
+   if (pWriteBuffer == NULL)
+   {
+      return -ENOMEM;
+   }
+
+   transactionID = QMIXactionIDGet(pDev);
+
+   /* send a QMI_CTL_SYNC_REQ (0x0027) */
+   result = QMICTLSyncReq( pWriteBuffer,
+                           writeBufferSize,
+                           transactionID );
+   if (result < 0)
+   {
+      kfree( pWriteBuffer );
+      return result;
+   }
+
+   result = WriteSync( pDev,
+                       pWriteBuffer,
+                       writeBufferSize,
+                       QMICTL );
+
+   if (result < 0)
+   {
+      kfree( pWriteBuffer );
+      return result;
+   }
+
+   // QMI CTL Sync Response
+   result = ReadSync( pDev,
+                      &pReadBuffer,
+                      QMICTL,
+                      transactionID );
+   if (result < 0)
+   {
+      return result;
+   }
+
+   result = QMICTLSyncResp( pReadBuffer,
+                            (u16)result );
+
+   kfree( pReadBuffer );
+
+   if (result < 0) /* need to re-sync */
+   {
+      DBG( "sync response error code %d\n", result );
+      /* start timer and wait for the response */
+      /* process response */
+      return result;
+   }
+
+#if 1 //free these ununsed qmi response, or when these transactionID re-used, they will be regarded as qmi response of the qmi request that have same transactionID
+   // Enter critical section
+   spin_lock_irqsave( &pDev->mQMIDev.mClientMemLock, flags );
+
+   // Free any unread data
+   while (PopFromReadMemList( pDev, QMICTL, 0, &pReadBuffer, &readBufferSize) == true) {	
+       kfree( pReadBuffer ); 
+   }
+   
+   // End critical section
+   spin_unlock_irqrestore( &pDev->mQMIDev.mClientMemLock, flags );    
+#endif
+  
+   // Success
+   return 0;
+}
+
+static int qmi_sync_thread(void *data) {
+    sGobiUSBNet * pDev = (sGobiUSBNet *)data;
+    int result = 0;
+
+#if 1  
+   // Device is not ready for QMI connections right away
+   //   Wait up to 30 seconds before failing
+   if (QMIReady( pDev, 30000 ) == false)
+   {
+      DBG( "Device unresponsive to QMI\n" );
+      goto __qmi_sync_finished;
+   }
+
+   // Initiate QMI CTL Sync Procedure
+   DBG( "Sending QMI CTL Sync Request\n" );
+   result = QMICTLSyncProc(pDev);
+   if (result != 0)
+   {
+      DBG( "QMI CTL Sync Procedure Error\n" );
+      goto __qmi_sync_finished;
+   }
+   else
+   {
+      DBG( "QMI CTL Sync Procedure Successful\n" );
+   }
+
+   // Setup Data Format
+   result = QMIWDASetDataFormat (pDev);
+   if (result != 0)
+   {
+      goto __qmi_sync_finished;
+   }
+
+   // Setup WDS callback
+   result = SetupQMIWDSCallback( pDev );
+   if (result != 0)
+   {
+      goto __qmi_sync_finished;
+   }
+
+   // Fill MEID for device
+   result = QMIDMSGetMEID( pDev );
+   if (result != 0)
+   {
+      goto __qmi_sync_finished;
+   }
+
+   //Bind Mux Data Port Pre
+   {
+      int i =1;
+      for(i=1;i<9;i++)
+      {
+         result = QMIWDSBindMuxDataPre(pDev, i);
+         if (result != 0)
+         {
+            DBG( "QMIWDSBindMuxDataPre result %d %d-%s\n", i, result, __func__);
+            goto __qmi_sync_finished;
+         }
+      }
+   }
+
+   //Bind Mux Data Port
+   result = QMIWDSBindMuxData(pDev);
+   if (result != 0)
+   {
+      DBG( "QMIWDSBindMuxData result %d-%s\n", result, __func__);
+      goto __qmi_sync_finished;
+   }
+
+#endif
+
+__qmi_sync_finished:
+   pDev->mbQMIReady = true;
+   complete_all(&pDev->mQMIReadyCompletion);
+   if (atomic_dec_and_test(&pDev->refcount)) {
+      kfree( pDev );
+   }
+   return result;
+}
+
+/*===========================================================================
+METHOD:
+   RegisterQMIDevice (Public Method)
+
+DESCRIPTION:
+   QMI Device initialization function
+
+PARAMETERS:
+   pDev     [ I ] - Device specific memory
+   
+RETURN VALUE:
+   int - 0 for success
+         Negative errno for failure
+===========================================================================*/
+int RegisterQMIDevice( sGobiUSBNet * pDev )
+{
+   int result;
+   int GobiQMIIndex = 0;
+   dev_t devno; 
+   char * pDevName;
+
+   if (pDev->mQMIDev.mbCdevIsInitialized == true)
+   {
+      // Should never happen, but always better to check
+      DBG( "device already exists\n" );
+      return -EEXIST;
+   }
+ 
+   pDev->mbQMIValid = true;
+   pDev->mbDeregisterQMIDevice = false;
+
+   // Set up for QMICTL
+   //    (does not send QMI message, just sets up memory)
+   result = GetClientID( pDev, QMICTL );
+   if (result != 0)
+   {
+      pDev->mbQMIValid = false;
+      return result;
+   }
+   atomic_set( &pDev->mQMIDev.mQMICTLTransactionID, 1 );
+
+   // Start Async reading
+   result = StartRead( pDev );
+   if (result != 0)
+   {
+	  pDev->mbQMIValid = false;
+      return result;
+   }
+
+   if ((pDev->mpNetDev->udev->descriptor.idVendor == cpu_to_le16(0x2CB7)) ||
+       (pDev->mpNetDev->udev->descriptor.idVendor == cpu_to_le16(0x05C6)) ||
+       (pDev->mpNetDev->udev->descriptor.idVendor == cpu_to_le16(0x1508)))
+   {
+      usb_control_msg( pDev->mpNetDev->udev,
+                            usb_sndctrlpipe( pDev->mpNetDev->udev, 0 ),
+                             SET_CONTROL_LINE_STATE_REQUEST,
+                             SET_CONTROL_LINE_STATE_REQUEST_TYPE,
+                             CONTROL_DTR,
+                             /* USB interface number to receive control message */
+                             pDev->mpIntf->cur_altsetting->desc.bInterfaceNumber,
+                             NULL,
+                             0,
+                             100 );
+   }
+
+    //for NL650/660/678, must wait about 15 seconds to wait QMI ready. it is too long for driver probe(will block other drivers probe).
+   if ((pDev->mpNetDev->udev->descriptor.idVendor == cpu_to_le16(0x2CB7)) ||
+       (pDev->mpNetDev->udev->descriptor.idVendor == cpu_to_le16(0x05C6)) ||
+       (pDev->mpNetDev->udev->descriptor.idVendor == cpu_to_le16(0x1508)))
+   {
+      struct task_struct *qmi_sync_task;
+      atomic_inc(&pDev->refcount);
+      init_completion(&pDev->mQMIReadyCompletion);
+      pDev->mbQMIReady = false;
+      qmi_sync_task = kthread_run(qmi_sync_thread, (void *)pDev, "qmi_sync/%d", pDev->mpNetDev->udev->devnum);
+       if (IS_ERR(qmi_sync_task)) {
+         atomic_dec(&pDev->refcount);
+         DBG( "Create qmi_sync_thread fail\n" );
+         return PTR_ERR(qmi_sync_task);
+      }
+      goto __register_chardev_qccmi;
+   }
+   
+   // Device is not ready for QMI connections right away
+   //   Wait up to 30 seconds before failing
+   if (QMIReady( pDev, 30000 ) == false)
+   {
+      DBG( "Device unresponsive to QMI\n" );
+      return -ETIMEDOUT;
+   }
+
+   // Initiate QMI CTL Sync Procedure
+   DBG( "Sending QMI CTL Sync Request\n" );
+   result = QMICTLSyncProc(pDev);
+   if (result != 0)
+   {
+      DBG( "QMI CTL Sync Procedure Error\n" );
+      return result;
+   }
+   else
+   {
+      DBG( "QMI CTL Sync Procedure Successful\n" );
+   }
+
+   // Setup Data Format
+   result = QMIWDASetDataFormat (pDev);
+   if (result != 0)
+   {
+       return result;
+   }
+
+   // Setup WDS callback
+   result = SetupQMIWDSCallback( pDev );
+   if (result != 0)
+   {
+	  return result;
+   }
+
+   // Fill MEID for device
+   result = QMIDMSGetMEID( pDev );
+   if (result != 0)
+   {
+      return result;
+   }
+#if 0  //delete for test yangyx 2019.09.28 begin
+   //Bind Mux Data Port Pre
+   {
+      int i =1;
+      for(i=1;i<9;i++)
+      {
+         result = QMIWDSBindMuxDataPre(pDev, i);
+         if (result != 0)
+         {
+            DBG( "QMIWDSBindMuxDataPre result %d %d-%s\n", i, result, __func__);
+            return result;
+         }
+      }
+   }
+#endif //delete for test yangyx 2019.09.28 end
+   //Bind Mux Data Port
+   result = QMIWDSBindMuxData(pDev);
+   if (result != 0)
+   {
+      DBG( "QMIWDSBindMuxData result %d\n", result);
+      return result;
+   }
+
+__register_chardev_qccmi:
+   // allocate and fill devno with numbers
+   result = alloc_chrdev_region( &devno, 0, 1, "qcqmi" );
+   if (result < 0)
+   {
+ 	  return result;
+   }
+
+   // Create cdev
+   cdev_init( &pDev->mQMIDev.mCdev, &UserspaceQMIFops );
+   pDev->mQMIDev.mCdev.owner = THIS_MODULE;
+   pDev->mQMIDev.mCdev.ops = &UserspaceQMIFops;
+   pDev->mQMIDev.mbCdevIsInitialized = true;
+
+   result = cdev_add( &pDev->mQMIDev.mCdev, devno, 1 );
+   if (result != 0)
+   {
+      DBG( "error adding cdev\n" );
+      return result;
+   }
+
+   // Match interface number (usb# or eth#)
+   if (!!(pDevName = strstr( pDev->mpNetDev->net->name, "eth" ))) {
+       pDevName += strlen( "eth" );
+   } else if (!!(pDevName = strstr( pDev->mpNetDev->net->name, "usb" ))) {
+       pDevName += strlen( "usb" );
+   } else {
+      DBG( "Bad net name: %s\n", pDev->mpNetDev->net->name );
+      return -ENXIO;
+   }
+   GobiQMIIndex = simple_strtoul( pDevName, NULL, 10 );
+   if (GobiQMIIndex < 0)
+   {
+      DBG( "Bad minor number\n" );
+      return -ENXIO;
+   }
+
+   // Always print this output
+   printk( KERN_INFO "creating qcqmi%d\n",
+           GobiQMIIndex );
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION( 2,6,27 ))
+   // kernel 2.6.27 added a new fourth parameter to device_create
+   //    void * drvdata : the data to be added to the device for callbacks
+   device_create( pDev->mQMIDev.mpDevClass,
+                  &pDev->mpIntf->dev, 
+                  devno,
+                  NULL,
+                  "qcqmi%d", 
+                  GobiQMIIndex );
+#else
+   device_create( pDev->mQMIDev.mpDevClass,
+                  &pDev->mpIntf->dev, 
+                  devno,
+                  "qcqmi%d", 
+                  GobiQMIIndex );
+#endif
+   
+   pDev->mQMIDev.mDevNum = devno;
+
+   // Success
+   return 0;
+}
+
+/*===========================================================================
+METHOD:
+   DeregisterQMIDevice (Public Method)
+
+DESCRIPTION:
+   QMI Device cleanup function
+   
+   NOTE: When this function is run the device is no longer valid
+
+PARAMETERS:
+   pDev     [ I ] - Device specific memory
+
+RETURN VALUE:
+   None
+===========================================================================*/
+void DeregisterQMIDevice( sGobiUSBNet * pDev )
+{
+   struct inode * pOpenInode;
+   struct list_head * pInodeList;
+   struct task_struct * pEachTask;
+   struct fdtable * pFDT;
+   struct file * pFilp;
+   unsigned long flags;
+   int count = 0;
+   int tries;
+   int result;
+
+   // Should never happen, but check anyway
+   if (IsDeviceValid( pDev ) == false)
+   {
+      DBG( "wrong device\n" );
+      return;
+   }
+
+   pDev->mbDeregisterQMIDevice = true;
+
+   // Release all clients
+   spin_lock_irqsave( &pDev->mQMIDev.mClientMemLock, flags );
+   while (pDev->mQMIDev.mpClientMemList != NULL)
+   {
+      u16 mClientID = pDev->mQMIDev.mpClientMemList->mClientID;
+      if (waitqueue_active(&pDev->mQMIDev.mpClientMemList->mWaitQueue)) {
+         DBG("WaitQueue 0x%04X\n", mClientID);
+         wake_up_interruptible_sync( &pDev->mQMIDev.mpClientMemList->mWaitQueue );
+         spin_unlock_irqrestore( &pDev->mQMIDev.mClientMemLock, flags );      
+         msleep(10);
+         spin_lock_irqsave( &pDev->mQMIDev.mClientMemLock, flags );
+         continue;
+      }
+
+      DBG( "release 0x%04X\n", pDev->mQMIDev.mpClientMemList->mClientID );
+   
+      spin_unlock_irqrestore( &pDev->mQMIDev.mClientMemLock, flags );
+      ReleaseClientID( pDev, mClientID );
+      // NOTE: pDev->mQMIDev.mpClientMemList will 
+      //       be updated in ReleaseClientID()
+      spin_lock_irqsave( &pDev->mQMIDev.mClientMemLock, flags );
+   }
+   spin_unlock_irqrestore( &pDev->mQMIDev.mClientMemLock, flags );
+
+   // Stop all reads
+   KillRead( pDev );
+
+   pDev->mbQMIValid = false;
+
+   if (pDev->mQMIDev.mbCdevIsInitialized == false)
+   {
+      return;
+   }
+
+   // Find each open file handle, and manually close it
+   
+   // Generally there will only be only one inode, but more are possible
+   list_for_each( pInodeList, &pDev->mQMIDev.mCdev.list )
+   {
+      // Get the inode
+      pOpenInode = container_of( pInodeList, struct inode, i_devices );
+      if (pOpenInode != NULL && (IS_ERR( pOpenInode ) == false))
+      {
+         // Look for this inode in each task
+
+         rcu_read_lock();
+         for_each_process( pEachTask )
+         {
+            task_lock(pEachTask);
+            if (pEachTask == NULL || pEachTask->files == NULL)
+            {
+               // Some tasks may not have files (e.g. Xsession)
+               task_unlock(pEachTask);
+               continue;
+            }
+            // For each file this task has open, check if it's referencing
+            // our inode.
+            spin_lock_irqsave( &pEachTask->files->file_lock, flags );
+            task_unlock(pEachTask);  //kernel/exit.c:do_exit() -> fs/file.c:exit_files()
+            pFDT = files_fdtable( pEachTask->files );
+            for (count = 0; count < pFDT->max_fds; count++)
+            {
+               pFilp = pFDT->fd[count];
+               if (pFilp != NULL &&  pFilp->f_dentry != NULL)
+               {
+                  if (pFilp->f_dentry->d_inode == pOpenInode)
+                  {
+                     // Close this file handle
+                     rcu_assign_pointer( pFDT->fd[count], NULL );                     
+                     spin_unlock_irqrestore( &pEachTask->files->file_lock, flags );
+                     
+                     DBG( "forcing close of open file handle\n" );
+                     filp_close( pFilp, pEachTask->files );
+
+                     spin_lock_irqsave( &pEachTask->files->file_lock, flags );
+                  }
+               }
+            }
+            spin_unlock_irqrestore( &pEachTask->files->file_lock, flags );
+         }
+         rcu_read_unlock();
+      }
+   }
+
+   // Send SetControlLineState request (USB_CDC)
+   result = usb_control_msg( pDev->mpNetDev->udev,
+                             usb_sndctrlpipe( pDev->mpNetDev->udev, 0 ),
+                             SET_CONTROL_LINE_STATE_REQUEST,
+                             SET_CONTROL_LINE_STATE_REQUEST_TYPE,
+                             0, // DTR not present
+                             /* USB interface number to receive control message */
+                             pDev->mpIntf->cur_altsetting->desc.bInterfaceNumber,
+                             NULL,
+                             0,
+                             100 );
+   if (result < 0)
+   {
+      DBG( "Bad SetControlLineState status %d\n", result );
+   }
+
+   // Remove device (so no more calls can be made by users)
+   if (IS_ERR( pDev->mQMIDev.mpDevClass ) == false)
+   {
+      device_destroy( pDev->mQMIDev.mpDevClass, 
+                      pDev->mQMIDev.mDevNum );   
+   }
+
+   // Hold onto cdev memory location until everyone is through using it.
+   // Timeout after 30 seconds (10 ms interval).  Timeout should never happen,
+   // but exists to prevent an infinate loop just in case.
+   for (tries = 0; tries < 30 * 100; tries++)
+   {
+   //https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.11.1
+   //from 4.11.1 that kref is using the refcount apis,for the detail info look the web above
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION( 4,10,9 ))
+		 int ref = atomic_read( &pDev->mQMIDev.mCdev.kobj.kref.refcount );
+#else
+		 int ref = atomic_read( &pDev->mQMIDev.mCdev.kobj.kref.refcount.refs );
+#endif
+      if (ref > 1)
+      {
+         DBG( "cdev in use by %d tasks\n", ref - 1 ); 
+         msleep( 10 );
+      }
+      else
+      {
+         break;
+      }
+   }
+
+   cdev_del( &pDev->mQMIDev.mCdev );
+   
+   unregister_chrdev_region( pDev->mQMIDev.mDevNum, 1 );
+
+   return;
+}
+
+/*=========================================================================*/
+// Driver level client management
+/*=========================================================================*/
+
+/*===========================================================================
+METHOD:
+   QMIReady (Public Method)
+
+DESCRIPTION:
+   Send QMI CTL GET VERSION INFO REQ and SET DATA FORMAT REQ
+   Wait for response or timeout
+
+PARAMETERS:
+   pDev     [ I ] - Device specific memory
+   timeout  [ I ] - Milliseconds to wait for response
+
+RETURN VALUE:
+   bool
+===========================================================================*/
+bool QMIReady(
+   sGobiUSBNet *    pDev,
+   u16                timeout )
+{
+   int result;
+   void * pWriteBuffer;
+   u16 writeBufferSize;
+   void * pReadBuffer;
+   u16 readBufferSize;
+   struct semaphore readSem;
+   u16 curTime;
+   unsigned long flags;
+   u8 transactionID;
+   
+   if (IsDeviceValid( pDev ) == false)
+   {
+      DBG( "Invalid device\n" );
+      return false;
+   }
+
+   writeBufferSize = QMICTLReadyReqSize();
+   pWriteBuffer = kmalloc( writeBufferSize, GFP_KERNEL );
+   if (pWriteBuffer == NULL)
+   {
+      return false;
+   }
+
+   // An implimentation of down_timeout has not been agreed on,
+   //    so it's been added and removed from the kernel several times.
+   //    We're just going to ignore it and poll the semaphore.
+
+   // Send a write every 1000 ms and see if we get a response
+   for (curTime = 0; curTime < timeout; curTime += 1000)
+   {
+      // Start read
+      sema_init( &readSem, 0 );
+   
+      transactionID = QMIXactionIDGet( pDev );
+
+      result = ReadAsync( pDev, QMICTL, transactionID, UpSem, &readSem );
+      if (result != 0)
+      {
+         kfree( pWriteBuffer );
+         return false;
+      }
+
+      // Fill buffer
+      result = QMICTLReadyReq( pWriteBuffer, 
+                               writeBufferSize,
+                               transactionID );
+      if (result < 0)
+      {
+         kfree( pWriteBuffer );
+         return false;
+      }
+
+      // Disregard status.  On errors, just try again
+      WriteSync( pDev,
+                 pWriteBuffer,
+                 writeBufferSize,
+                 QMICTL );
+
+      msleep( 1000 );
+      if (down_trylock( &readSem ) == 0)
+      {
+         // Enter critical section
+         spin_lock_irqsave( &pDev->mQMIDev.mClientMemLock, flags );
+
+         // Pop the read data
+         if (PopFromReadMemList( pDev,
+                                 QMICTL,
+                                 transactionID,
+                                 &pReadBuffer,
+                                 &readBufferSize ) == true)
+         {
+            // Success
+
+            // End critical section
+            spin_unlock_irqrestore( &pDev->mQMIDev.mClientMemLock, flags );
+         
+            // We don't care about the result
+            kfree( pReadBuffer );
+
+            break;
+         }
+         else
+         {
+            // Read mismatch/failure, unlock and continue
+            spin_unlock_irqrestore( &pDev->mQMIDev.mClientMemLock, flags );
+         }
+      }
+      else
+      {
+         // Enter critical section
+         spin_lock_irqsave( &pDev->mQMIDev.mClientMemLock, flags );
+         
+         // Timeout, remove the async read
+         NotifyAndPopNotifyList( pDev, QMICTL, transactionID );
+         
+         // End critical section
+         spin_unlock_irqrestore( &pDev->mQMIDev.mClientMemLock, flags );
+      }
+   }
+
+   kfree( pWriteBuffer );
+
+   // Did we time out?   
+   if (curTime >= timeout)
+   {
+      return false;
+   }
+   
+   DBG( "QMI Ready after %u milliseconds\n", curTime );
+
+   // Success
+   return true;
+}
+
+/*===========================================================================
+METHOD:
+   QMIWDSCallback (Public Method)
+
+DESCRIPTION:
+   QMI WDS callback function
+   Update net stats or link state
+
+PARAMETERS:
+   pDev     [ I ] - Device specific memory
+   clientID [ I ] - Client ID
+   pData    [ I ] - Callback data (unused)
+
+RETURN VALUE:
+   None
+===========================================================================*/
+void QMIWDSCallback(
+   sGobiUSBNet *    pDev,
+   u16                clientID,
+   void *             pData )
+{
+   bool bRet;
+   int result;
+   void * pReadBuffer;
+   u16 readBufferSize;
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,31 ))
+   struct net_device_stats * pStats = &(pDev->mpNetDev->stats);
+#else
+   struct net_device_stats * pStats = &(pDev->mpNetDev->net->stats);
+#endif
+
+   u32 TXOk = (u32)-1;
+   u32 RXOk = (u32)-1;
+   u32 TXErr = (u32)-1;
+   u32 RXErr = (u32)-1;
+   u32 TXOfl = (u32)-1;
+   u32 RXOfl = (u32)-1;
+   u64 TXBytesOk = (u64)-1;
+   u64 RXBytesOk = (u64)-1;
+   bool bLinkState;
+   bool bReconfigure;
+   unsigned long flags;
+   
+   if (IsDeviceValid( pDev ) == false)
+   {
+      DBG( "Invalid device\n" );
+      return;
+   }
+
+   // Critical section
+   spin_lock_irqsave( &pDev->mQMIDev.mClientMemLock, flags );
+   
+   bRet = PopFromReadMemList( pDev,
+                              clientID,
+                              0,
+                              &pReadBuffer,
+                              &readBufferSize );
+   
+   // End critical section
+   spin_unlock_irqrestore( &pDev->mQMIDev.mClientMemLock, flags ); 
+   
+   if (bRet == false)
+   {
+      DBG( "WDS callback failed to get data\n" );
+      return;
+   }
+   
+   // Default values
+   bLinkState = ! GobiTestDownReason( pDev, NO_NDIS_CONNECTION );
+   bReconfigure = false;
+
+   result = QMIWDSEventResp( pReadBuffer,
+                             readBufferSize,
+                             &TXOk,
+                             &RXOk,
+                             &TXErr,
+                             &RXErr,
+                             &TXOfl,
+                             &RXOfl,
+                             &TXBytesOk,
+                             &RXBytesOk,
+                             &bLinkState,
+                             &bReconfigure );
+   if (result < 0)
+   {
+      DBG( "bad WDS packet\n" );
+   }
+   else
+   {
+
+      // Fill in new values, ignore max values
+      if (TXOfl != (u32)-1)
+      {
+         pStats->tx_fifo_errors = TXOfl;
+      }
+      
+      if (RXOfl != (u32)-1)
+      {
+         pStats->rx_fifo_errors = RXOfl;
+      }
+
+      if (TXErr != (u32)-1)
+      {
+         pStats->tx_errors = TXErr;
+      }
+      
+      if (RXErr != (u32)-1)
+      {
+         pStats->rx_errors = RXErr;
+      }
+
+      if (TXOk != (u32)-1)
+      {
+         pStats->tx_packets = TXOk + pStats->tx_errors;
+      }
+      
+      if (RXOk != (u32)-1)
+      {
+         pStats->rx_packets = RXOk + pStats->rx_errors;
+      }
+
+      if (TXBytesOk != (u64)-1)
+      {
+         pStats->tx_bytes = TXBytesOk;
+      }
+      
+      if (RXBytesOk != (u64)-1)
+      {
+         pStats->rx_bytes = RXBytesOk;
+      }
+
+      if (bReconfigure == true)
+      {
+         DBG( "Net device link reset\n" );
+         GobiSetDownReason( pDev, NO_NDIS_CONNECTION );
+         GobiClearDownReason( pDev, NO_NDIS_CONNECTION );
+      }
+      else
+      {
+         if (bLinkState == true)
+         {
+            if (GobiTestDownReason( pDev, NO_NDIS_CONNECTION )) {
+                DBG( "Net device link is connected\n" );
+                GobiClearDownReason( pDev, NO_NDIS_CONNECTION );
+            }
+         }
+         else
+         {
+            if (!GobiTestDownReason( pDev, NO_NDIS_CONNECTION )) {
+                DBG( "Net device link is disconnected\n" );
+                GobiSetDownReason( pDev, NO_NDIS_CONNECTION );
+            }
+         }
+      }
+   }
+
+   kfree( pReadBuffer );
+
+   // Setup next read
+   result = ReadAsync( pDev,
+                       clientID,
+                       0,
+                       QMIWDSCallback,
+                       pData );
+   if (result != 0)
+   {
+      DBG( "unable to setup next async read\n" );
+   }
+
+   return;
+}
+
+/*===========================================================================
+METHOD:
+   SetupQMIWDSCallback (Public Method)
+
+DESCRIPTION:
+   Request client and fire off reqests and start async read for 
+   QMI WDS callback
+
+PARAMETERS:
+   pDev     [ I ] - Device specific memory
+
+RETURN VALUE:
+   int - 0 for success
+         Negative errno for failure
+===========================================================================*/
+int SetupQMIWDSCallback( sGobiUSBNet * pDev )
+{
+   int result;
+   void * pWriteBuffer;
+   u16 writeBufferSize;
+   u16 WDSClientID;
+
+   if (IsDeviceValid( pDev ) == false)
+   {
+      DBG( "Invalid device\n" );
+      return -EFAULT;
+   }
+   
+   result = GetClientID( pDev, QMIWDS );
+   if (result < 0)
+   {
+      return result;
+   }
+   WDSClientID = result;
+
+   // QMI WDS Set Event Report
+   writeBufferSize = QMIWDSSetEventReportReqSize();
+   pWriteBuffer = kmalloc( writeBufferSize, GFP_KERNEL );
+   if (pWriteBuffer == NULL)
+   {
+      return -ENOMEM;
+   }
+   
+   result = QMIWDSSetEventReportReq( pWriteBuffer, 
+                                     writeBufferSize,
+                                     1 );
+   if (result < 0)
+   {
+      kfree( pWriteBuffer );
+      return result;
+   }
+
+   result = WriteSync( pDev,
+                       pWriteBuffer,
+                       writeBufferSize,
+                       WDSClientID );
+   kfree( pWriteBuffer );
+
+   if (result < 0)
+   {
+      return result;
+   }
+
+   // QMI WDS Get PKG SRVC Status
+   writeBufferSize = QMIWDSGetPKGSRVCStatusReqSize();
+   pWriteBuffer = kmalloc( writeBufferSize, GFP_KERNEL );
+   if (pWriteBuffer == NULL)
+   {
+      return -ENOMEM;
+   }
+
+   result = QMIWDSGetPKGSRVCStatusReq( pWriteBuffer, 
+                                       writeBufferSize,
+                                       2 );
+   if (result < 0)
+   {
+      kfree( pWriteBuffer );
+      return result;
+   }
+   
+   result = WriteSync( pDev,
+                       pWriteBuffer,
+                       writeBufferSize,
+                       WDSClientID );
+   kfree( pWriteBuffer );
+
+   if (result < 0)
+   {
+      return result;
+   }
+
+   // Setup asnyc read callback
+   result = ReadAsync( pDev,
+                       WDSClientID,
+                       0,
+                       QMIWDSCallback,
+                       NULL );
+   if (result != 0)
+   {
+      DBG( "unable to setup async read\n" );
+      return result;
+   }
+
+   // Send SetControlLineState request (USB_CDC)
+   //   Required for Autoconnect
+   result = usb_control_msg( pDev->mpNetDev->udev,
+                             usb_sndctrlpipe( pDev->mpNetDev->udev, 0 ),
+                             SET_CONTROL_LINE_STATE_REQUEST,
+                             SET_CONTROL_LINE_STATE_REQUEST_TYPE,
+                             CONTROL_DTR,
+                             /* USB interface number to receive control message */
+                             pDev->mpIntf->cur_altsetting->desc.bInterfaceNumber,
+                             NULL,
+                             0,
+                             100 );
+   if (result < 0)
+   {
+      DBG( "Bad SetControlLineState status %d\n", result );
+      return result;
+   }
+
+   return 0;
+}
+
+/*===========================================================================
+METHOD:
+   QMIDMSGetMEID (Public Method)
+
+DESCRIPTION:
+   Register DMS client
+   send MEID req and parse response
+   Release DMS client
+
+PARAMETERS:
+   pDev     [ I ] - Device specific memory
+
+RETURN VALUE:
+   None
+===========================================================================*/
+int QMIDMSGetMEID( sGobiUSBNet * pDev )
+{
+   int result;
+   void * pWriteBuffer;
+   u16 writeBufferSize;
+   void * pReadBuffer;
+   u16 readBufferSize;
+   u16 DMSClientID;
+
+   if (IsDeviceValid( pDev ) == false)
+   {
+      DBG( "Invalid device\n" );
+      return -EFAULT;
+   }
+
+   result = GetClientID( pDev, QMIDMS );
+   if (result < 0)
+   {
+      return result;
+   }
+   DMSClientID = result;
+
+   // QMI DMS Get Serial numbers Req
+   writeBufferSize = QMIDMSGetMEIDReqSize();
+   pWriteBuffer = kmalloc( writeBufferSize, GFP_KERNEL );
+   if (pWriteBuffer == NULL)
+   {
+      return -ENOMEM;
+   }
+
+   result = QMIDMSGetMEIDReq( pWriteBuffer, 
+                              writeBufferSize,
+                              1 );
+   if (result < 0)
+   {
+      kfree( pWriteBuffer );
+      return result;
+   }
+
+   result = WriteSync( pDev,
+                       pWriteBuffer,
+                       writeBufferSize,
+                       DMSClientID );
+   kfree( pWriteBuffer );
+
+   if (result < 0)
+   {
+      return result;
+   }
+
+   // QMI DMS Get Serial numbers Resp
+   result = ReadSync( pDev,
+                      &pReadBuffer,
+                      DMSClientID,
+                      1 );
+   if (result < 0)
+   {
+      return result;
+   }
+   readBufferSize = result;
+
+   result = QMIDMSGetMEIDResp( pReadBuffer,
+                               readBufferSize,
+                               &pDev->mMEID[0],
+                               14 );
+   kfree( pReadBuffer );
+
+   if (result < 0)
+   {
+      DBG( "bad get MEID resp\n" );
+      
+      // Non fatal error, device did not return any MEID
+      //    Fill with 0's
+      memset( &pDev->mMEID[0], '0', 14 );
+   }
+
+   ReleaseClientID( pDev, DMSClientID );
+
+   // Success
+   return 0;
+}
+
+/*===========================================================================
+METHOD:
+   QMIWDASetDataFormat (Public Method)
+
+DESCRIPTION:
+   Register WDA client
+   send Data format request and parse response
+   Release WDA client
+
+PARAMETERS:
+   pDev     [ I ] - Device specific memory
+
+RETURN VALUE:
+   None
+===========================================================================*/
+int QMIWDASetDataFormat( sGobiUSBNet * pDev )
+{
+   int result;
+   void * pWriteBuffer;
+   u16 writeBufferSize;
+   void * pReadBuffer;
+   u16 readBufferSize;
+   u16 WDAClientID;
+
+   DBG("\n");
+
+   if (IsDeviceValid( pDev ) == false)
+   {
+      DBG( "Invalid device\n" );
+      return -EFAULT;
+   }
+
+   result = GetClientID( pDev, QMIWDA );
+   if (result < 0)
+   {
+      return result;
+   }
+   WDAClientID = result;
+
+   // QMI WDA Set Data Format Request
+   writeBufferSize = QMIWDASetDataFormatReqSize();
+   pWriteBuffer = kmalloc( writeBufferSize, GFP_KERNEL );
+   if (pWriteBuffer == NULL)
+   {
+      return -ENOMEM;
+   }
+
+   result = QMIWDASetDataFormatReq( pWriteBuffer,
+                              writeBufferSize,
+                                    1 );
+   if (result < 0)
+   {
+      kfree( pWriteBuffer );
+      return result;
+   }
+
+   result = WriteSync( pDev,
+                       pWriteBuffer,
+                       writeBufferSize,
+                       WDAClientID );
+   kfree( pWriteBuffer );
+
+   if (result < 0)
+   {
+      return result;
+   }
+
+   // QMI DMS Get Serial numbers Resp
+   result = ReadSync( pDev,
+                      &pReadBuffer,
+                      WDAClientID,
+                      1 );
+   if (result < 0)
+   {
+      return result;
+   }
+   readBufferSize = result;
+
+   result = QMIWDASetDataFormatResp( pReadBuffer,
+                                     readBufferSize );
+
+   kfree( pReadBuffer );
+
+#if 1 //def DATA_MODE_RP
+   pDev->mbRawIPMode = (result == 2);
+   if (pDev->mbRawIPMode) {
+       pDev->mpNetDev->net->flags |= IFF_NOARP;
+   }
+#endif
+
+   if (result < 0)
+   {
+      DBG( "Data Format Cannot be set\n" );
+   }
+
+   ReleaseClientID( pDev, WDAClientID );
+
+   // Success
+    return 0;
+}
+
+/*===========================================================================
+METHOD:
+   QMIWDSBindMuxData (Public Method)
+
+DESCRIPTION:
+   Register WDS client
+   send Bind Mux Data Port request and parse response
+   Release WDS client
+
+PARAMETERS:
+   pDev     [ I ] - Device specific memory
+
+RETURN VALUE:
+   None
+===========================================================================*/
+int QMIWDSBindMuxData( sGobiUSBNet * pDev )
+{
+   int result;
+   void * pWriteBuffer;
+   u16 writeBufferSize;
+   void * pReadBuffer;
+   u16 readBufferSize;
+   u16 WDSClientID;
+   u16 platid = 0; // 1:9x07;2:9x40; 
+
+   DBG("\n");
+
+   if (IsDeviceValid( pDev ) == false)
+   {
+      DBG( "Invalid device\n" );
+      return -EFAULT;
+   }
+
+   result = GetClientID( pDev, QMIWDS );
+   if (result < 0)
+   {
+      return result;
+   }
+   WDSClientID = result;
+
+   // QMI WDS Bind Mux Data Request
+   writeBufferSize = QMIWDSBindMuxDataPortReqSize();
+   pWriteBuffer = kmalloc( writeBufferSize, GFP_KERNEL );
+   if (pWriteBuffer == NULL)
+   {
+      return -ENOMEM;
+   }
+   
+   if (pDev->mpNetDev->udev->descriptor.idVendor == cpu_to_le16(0x1508))
+   {
+       platid = 1;
+   }else if ((pDev->mpNetDev->udev->descriptor.idVendor == cpu_to_le16(0x2CB7)) &&
+             ((pDev->mpNetDev->udev->descriptor.idProduct == cpu_to_le16(0x0104)) ||
+              (pDev->mpNetDev->udev->descriptor.idProduct == cpu_to_le16(0x0106)) ||
+              (pDev->mpNetDev->udev->descriptor.idProduct == cpu_to_le16(0x0109)))){
+       platid = 2;
+   }else if ((pDev->mpNetDev->udev->descriptor.idVendor == cpu_to_le16(0x05C6)) &&
+             (pDev->mpNetDev->udev->descriptor.idProduct == cpu_to_le16(0x90DB))){
+       platid = 2;
+   }
+
+   if (pDev->mpNetDev->udev->descriptor.idVendor == cpu_to_le16(0x2C7C) && (pDev->mpNetDev->udev->descriptor.idProduct == cpu_to_le16(0x0104))){
+       platid = 2;
+   }
+   result = QMIWDSBindMuxDataPortReq(platid, pWriteBuffer,
+                              writeBufferSize,
+                                    1 );
+   if (result < 0)
+   {
+      kfree( pWriteBuffer );
+      return result;
+   }
+
+   result = WriteSync( pDev,
+                       pWriteBuffer,
+                       writeBufferSize,
+                       WDSClientID );
+   kfree( pWriteBuffer );
+
+   if (result < 0)
+   {
+      return result;
+   }
+
+   // QMI DMS Get Serial numbers Resp
+   result = ReadSync( pDev,
+                      &pReadBuffer,
+                      WDSClientID,
+                      1 );
+   if (result < 0)
+   {
+      return result;
+   }
+   readBufferSize = result;
+
+   result = QMIWDSBindMuxDataPortResp( pReadBuffer,
+                                     readBufferSize );
+
+   kfree( pReadBuffer );
+
+   if (result < 0)
+   {
+      DBG( "Data Format Cannot be set\n" );
+   }
+
+   ReleaseClientID( pDev, WDSClientID );
+
+   // Success
+    return 0;
+}
+
+/*===========================================================================
+METHOD:
+   QMIWDSBindMuxDataPre (Public Method)
+
+DESCRIPTION:
+   Register WDS client
+   send Bind Mux Data Port request and parse response
+   Release WDS client
+
+PARAMETERS:
+   pDev     [ I ] - Device specific memory
+
+RETURN VALUE:
+   None
+===========================================================================*/
+int QMIWDSBindMuxDataPre( sGobiUSBNet * pDev, unsigned int index )
+{
+   int result;
+   void * pWriteBuffer;
+   u16 writeBufferSize;
+   void * pReadBuffer;
+   u16 readBufferSize;
+   u16 WDSClientID;
+
+   DBG("\n");
+
+   if (IsDeviceValid( pDev ) == false)
+   {
+      DBG( "Invalid device\n" );
+      return -EFAULT;
+   }
+
+   result = GetClientID( pDev, QMIWDS );
+   if (result < 0)
+   {
+      return result;
+   }
+   WDSClientID = result;
+
+   // QMI WDS Bind Mux Data Request
+   writeBufferSize = QMIWDSBindMuxDataPortPreReqSize();
+   pWriteBuffer = kmalloc( writeBufferSize, GFP_KERNEL );
+   if (pWriteBuffer == NULL)
+   {
+      return -ENOMEM;
+   }
+
+   result = QMIWDSBindMuxDataPortPreReq( pWriteBuffer,
+                              writeBufferSize,
+                                    1, index);
+   if (result < 0)
+   {
+      kfree( pWriteBuffer );
+      return result;
+   }
+
+   result = WriteSync( pDev,
+                       pWriteBuffer,
+                       writeBufferSize,
+                       WDSClientID );
+   kfree( pWriteBuffer );
+
+   if (result < 0)
+   {
+      return result;
+   }
+
+   // QMI DMS Get Serial numbers Resp
+   result = ReadSync( pDev,
+                      &pReadBuffer,
+                      WDSClientID,
+                      1 );
+   if (result < 0)
+   {
+      return result;
+   }
+   readBufferSize = result;
+
+   result = QMIWDSBindMuxDataPortResp( pReadBuffer,
+                                     readBufferSize );
+
+   kfree( pReadBuffer );
+
+   if (result < 0)
+   {
+      DBG( "Data Format Cannot be set\n" );
+   }
+
+   ReleaseClientID( pDev, WDSClientID );
+
+   // Success
+    return 0;
+}
diff -Naur a/drivers/net/usb/QMIDevice.h b/drivers/net/usb/QMIDevice.h
--- a/drivers/net/usb/QMIDevice.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/net/usb/QMIDevice.h	2020-01-15 10:23:12.973119537 +0800
@@ -0,0 +1,351 @@
+/*===========================================================================
+FILE:
+   QMIDevice.h
+
+DESCRIPTION:
+   Functions related to the QMI interface device
+   
+FUNCTIONS:
+   Generic functions
+      IsDeviceValid
+      PrintHex
+      GobiSetDownReason
+      GobiClearDownReason
+      GobiTestDownReason
+
+   Driver level asynchronous read functions
+      ResubmitIntURB
+      ReadCallback
+      IntCallback
+      StartRead
+      KillRead
+
+   Internal read/write functions
+      ReadAsync
+      UpSem
+      ReadSync
+      WriteSyncCallback
+      WriteSync
+
+   Internal memory management functions
+      GetClientID
+      ReleaseClientID
+      FindClientMem
+      AddToReadMemList
+      PopFromReadMemList
+      AddToNotifyList
+      NotifyAndPopNotifyList
+      AddToURBList
+      PopFromURBList
+
+   Internal userspace wrapper functions
+      UserspaceunlockedIOCTL
+
+   Userspace wrappers
+      UserspaceOpen
+      UserspaceIOCTL
+      UserspaceClose
+      UserspaceRead
+      UserspaceWrite
+      UserspacePoll
+
+   Initializer and destructor
+      RegisterQMIDevice
+      DeregisterQMIDevice
+
+   Driver level client management
+      QMIReady
+      QMIWDSCallback
+      SetupQMIWDSCallback
+      QMIDMSGetMEID
+
+Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of Code Aurora Forum nor
+      the names of its contributors may be used to endorse or promote
+      products derived from this software without specific prior written
+      permission.
+
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+===========================================================================*/
+
+//---------------------------------------------------------------------------
+// Pragmas
+//---------------------------------------------------------------------------
+#pragma once
+
+//---------------------------------------------------------------------------
+// Include Files
+//---------------------------------------------------------------------------
+#include "Structs.h"
+#include "QMI.h"
+
+/*=========================================================================*/
+// Generic functions
+/*=========================================================================*/
+
+// Basic test to see if device memory is valid
+bool IsDeviceValid( sGobiUSBNet * pDev );
+
+// Print Hex data, for debug purposes
+void PrintHex(
+   void *         pBuffer,
+   u16            bufSize );
+
+// Sets mDownReason and turns carrier off
+void GobiSetDownReason(
+   sGobiUSBNet *    pDev,
+   u8                 reason );
+
+// Clear mDownReason and may turn carrier on
+void GobiClearDownReason(
+   sGobiUSBNet *    pDev,
+   u8                 reason );
+
+// Tests mDownReason and returns whether reason is set
+bool GobiTestDownReason(
+   sGobiUSBNet *    pDev,
+   u8                 reason );
+
+/*=========================================================================*/
+// Driver level asynchronous read functions
+/*=========================================================================*/
+
+// Resubmit interrupt URB, re-using same values
+int ResubmitIntURB( struct urb * pIntURB );
+
+// Read callback
+//    Put the data in storage and notify anyone waiting for data
+#if (LINUX_VERSION_CODE > KERNEL_VERSION( 2,6,14 ))
+void ReadCallback( struct urb * pReadURB );
+#else
+void ReadCallback(struct urb *pReadURB, struct pt_regs *regs);
+#endif
+
+// Inturrupt callback
+//    Data is available, start a read URB
+#if (LINUX_VERSION_CODE > KERNEL_VERSION( 2,6,14 ))
+void IntCallback( struct urb * pIntURB );
+#else
+void IntCallback(struct urb *pIntURB, struct pt_regs *regs);
+#endif
+
+// Start continuous read "thread"
+int StartRead( sGobiUSBNet * pDev );
+
+// Kill continuous read "thread"
+void KillRead( sGobiUSBNet * pDev );
+
+/*=========================================================================*/
+// Internal read/write functions
+/*=========================================================================*/
+
+// Start asynchronous read
+//     Reading client's data store, not device
+int ReadAsync(
+   sGobiUSBNet *    pDev,
+   u16                clientID,
+   u16                transactionID,
+   void               (*pCallback)(sGobiUSBNet *, u16, void *),
+   void *             pData );
+
+// Notification function for synchronous read
+void UpSem( 
+   sGobiUSBNet *    pDev,
+   u16                clientID,
+   void *             pData );
+
+// Start synchronous read
+//     Reading client's data store, not device
+int ReadSync(
+   sGobiUSBNet *    pDev,
+   void **            ppOutBuffer,
+   u16                clientID,
+   u16                transactionID );
+
+// Write callback
+#if (LINUX_VERSION_CODE > KERNEL_VERSION( 2,6,14 ))
+void WriteSyncCallback( struct urb * pWriteURB );
+#else
+void WriteSyncCallback(struct urb *pWriteURB, struct pt_regs *regs);
+#endif
+
+// Start synchronous write
+int WriteSync(
+   sGobiUSBNet *    pDev,
+   char *             pInWriteBuffer,
+   int                size,
+   u16                clientID );
+
+/*=========================================================================*/
+// Internal memory management functions
+/*=========================================================================*/
+
+// Create client and allocate memory
+int GetClientID( 
+   sGobiUSBNet *      pDev,
+   u8                   serviceType );
+
+// Release client and free memory
+void ReleaseClientID(
+   sGobiUSBNet *      pDev,
+   u16                  clientID );
+
+// Find this client's memory
+sClientMemList * FindClientMem(
+   sGobiUSBNet *      pDev,
+   u16                  clientID );
+
+// Add Data to this client's ReadMem list
+bool AddToReadMemList( 
+   sGobiUSBNet *      pDev,
+   u16                  clientID,
+   u16                  transactionID,
+   void *               pData,
+   u16                  dataSize );
+
+// Remove data from this client's ReadMem list if it matches 
+// the specified transaction ID.
+bool PopFromReadMemList( 
+   sGobiUSBNet *      pDev,
+   u16                  clientID,
+   u16                  transactionID,
+   void **              ppData,
+   u16 *                pDataSize );
+
+// Add Notify entry to this client's notify List
+bool AddToNotifyList( 
+   sGobiUSBNet *      pDev,
+   u16                  clientID,
+   u16                  transactionID,
+   void                 (* pNotifyFunct)(sGobiUSBNet *, u16, void *),
+   void *               pData );
+
+// Remove first Notify entry from this client's notify list 
+//    and Run function
+bool NotifyAndPopNotifyList( 
+   sGobiUSBNet *      pDev,
+   u16                  clientID,
+   u16                  transactionID );
+
+// Add URB to this client's URB list
+bool AddToURBList( 
+   sGobiUSBNet *      pDev,
+   u16                  clientID,
+   struct urb *         pURB );
+
+// Remove URB from this client's URB list
+struct urb * PopFromURBList( 
+   sGobiUSBNet *      pDev,
+   u16                  clientID );
+
+/*=========================================================================*/
+// Internal userspace wrappers
+/*=========================================================================*/
+
+// Userspace unlocked ioctl
+long UserspaceunlockedIOCTL(
+   struct file *     pFilp,
+   unsigned int      cmd,
+   unsigned long     arg );
+
+/*=========================================================================*/
+// Userspace wrappers
+/*=========================================================================*/
+
+// Userspace open
+int UserspaceOpen( 
+   struct inode *   pInode, 
+   struct file *    pFilp );
+
+// Userspace ioctl
+int UserspaceIOCTL( 
+   struct inode *    pUnusedInode, 
+   struct file *     pFilp,
+   unsigned int      cmd, 
+   unsigned long     arg );
+
+// Userspace close
+#if (LINUX_VERSION_CODE > KERNEL_VERSION( 2,6,14 ))
+int UserspaceClose( 
+   struct file *       pFilp,
+   fl_owner_t          unusedFileTable );
+#else
+int UserspaceClose( struct file *       pFilp );
+#endif
+
+// Userspace read (synchronous)
+ssize_t UserspaceRead( 
+   struct file *        pFilp,
+   char __user *        pBuf, 
+   size_t               size,
+   loff_t *             pUnusedFpos );
+
+// Userspace write (synchronous)
+ssize_t UserspaceWrite(
+   struct file *        pFilp, 
+   const char __user *  pBuf, 
+   size_t               size,
+   loff_t *             pUnusedFpos );
+
+unsigned int UserspacePoll(
+   struct file *                  pFilp,
+   struct poll_table_struct *     pPollTable );
+
+/*=========================================================================*/
+// Initializer and destructor
+/*=========================================================================*/
+
+// QMI Device initialization function
+int RegisterQMIDevice( sGobiUSBNet * pDev );
+
+// QMI Device cleanup function
+void DeregisterQMIDevice( sGobiUSBNet * pDev );
+
+/*=========================================================================*/
+// Driver level client management
+/*=========================================================================*/
+
+// Check if QMI is ready for use
+bool QMIReady(
+   sGobiUSBNet *    pDev,
+   u16                timeout );
+
+// QMI WDS callback function
+void QMIWDSCallback(
+   sGobiUSBNet *    pDev,
+   u16                clientID,
+   void *             pData );
+
+// Fire off reqests and start async read for QMI WDS callback
+int SetupQMIWDSCallback( sGobiUSBNet * pDev );
+
+// Register client, send req and parse MEID response, release client
+int QMIDMSGetMEID( sGobiUSBNet * pDev );
+
+// Register client, send req and parse Data format response, release client
+int QMIWDASetDataFormat( sGobiUSBNet * pDev );
+
+// Register client, send req and parse Bind Mux Data Port response, release client
+int QMIWDSBindMuxData( sGobiUSBNet * pDev );
+
+// Register client, send req and parse Bind Mux Data Port Pre response, release client
+int QMIWDSBindMuxDataPre( sGobiUSBNet * pDev, unsigned int index );
diff -Naur a/drivers/net/usb/QMI.h b/drivers/net/usb/QMI.h
--- a/drivers/net/usb/QMI.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/net/usb/QMI.h	2020-01-15 10:23:34.108198885 +0800
@@ -0,0 +1,346 @@
+/*===========================================================================
+FILE:
+   QMI.h
+
+DESCRIPTION:
+   Qualcomm QMI driver header
+   
+FUNCTIONS:
+   Generic QMUX functions
+      ParseQMUX
+      FillQMUX
+   
+   Generic QMI functions
+      GetTLV
+      ValidQMIMessage
+      GetQMIMessageID
+
+   Get sizes of buffers needed by QMI requests
+      QMUXHeaderSize
+      QMICTLGetClientIDReqSize
+      QMICTLReleaseClientIDReqSize
+      QMICTLReadyReqSize
+      QMIWDSSetEventReportReqSize
+      QMIWDSGetPKGSRVCStatusReqSize
+      QMIDMSGetMEIDReqSize
+      QMICTLSyncReqSize
+
+   Fill Buffers with QMI requests
+      QMICTLGetClientIDReq
+      QMICTLReleaseClientIDReq
+      QMICTLReadyReq
+      QMIWDSSetEventReportReq
+      QMIWDSGetPKGSRVCStatusReq
+      QMIDMSGetMEIDReq
+      QMICTLSetDataFormatReq
+      QMICTLSyncReq
+      
+   Parse data from QMI responses
+      QMICTLGetClientIDResp
+      QMICTLReleaseClientIDResp
+      QMIWDSEventResp
+      QMIDMSGetMEIDResp
+
+Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of Code Aurora Forum nor
+      the names of its contributors may be used to endorse or promote
+      products derived from this software without specific prior written
+      permission.
+
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+===========================================================================*/
+
+#pragma once
+
+/*=========================================================================*/
+// Definitions
+/*=========================================================================*/
+
+extern int Gobi_debug;
+
+// DBG macro
+#define DBG( format, arg... ) do { \
+   if (Gobi_debug == 1)\
+   { \
+      printk( KERN_INFO "GobiNet::%s " format, __FUNCTION__, ## arg ); \
+   } }while(0)
+
+#if 0
+#define VDBG( format, arg... ) do { \
+   if (Gobi_debug == 1)\
+   { \
+      printk( KERN_INFO "GobiNet::%s " format, __FUNCTION__, ## arg ); \
+   } } while(0)
+#else
+#define VDBG( format, arg... ) do { } while(0)
+#endif
+
+// QMI Service Types
+#define QMICTL 0
+#define QMIWDS 1
+#define QMIDMS 2
+#define QMINAS 3
+#define QMIUIM 11
+#define QMIWDA 0x1A
+
+#define u8        unsigned char
+#define u16       unsigned short
+#define u32       unsigned int
+#define u64       unsigned long long
+
+#define bool      u8
+#define true      1
+#define false     0
+
+#define ENOMEM    12
+#define EFAULT    14
+#define EINVAL    22
+#ifndef ENOMSG
+#define ENOMSG    42
+#endif
+#define ENODATA   61
+
+#define TLV_TYPE_LINK_PROTO 0x10
+
+/*=========================================================================*/
+// Struct sQMUX
+//
+//    Structure that defines a QMUX header
+/*=========================================================================*/
+typedef struct sQMUX
+{
+   /* T\F, always 1 */
+   u8         mTF;
+
+   /* Size of message */
+   u16        mLength;
+
+   /* Control flag */
+   u8         mCtrlFlag;
+   
+   /* Service Type */
+   u8         mQMIService;
+   
+   /* Client ID */
+   u8         mQMIClientID;
+
+}__attribute__((__packed__)) sQMUX;
+
+/*=========================================================================*/
+// Generic functions
+/*=========================================================================*/
+int GetDeviceInterfaceNumber(void);
+void SetDeviceInterfaceNumber(int uInterfaceNulber);
+/*=========================================================================*/
+// Generic QMUX functions
+/*=========================================================================*/
+
+// Remove QMUX headers from a buffer
+int ParseQMUX(
+   u16 *    pClientID,
+   void *   pBuffer,
+   u16      buffSize );
+
+// Fill buffer with QMUX headers
+int FillQMUX(
+   u16      clientID,
+   void *   pBuffer,
+   u16      buffSize );
+
+/*=========================================================================*/
+// Generic QMI functions
+/*=========================================================================*/
+
+// Get data buffer of a specified TLV from a QMI message
+int GetTLV(
+   void *   pQMIMessage,
+   u16      messageLen,
+   u8       type,
+   void *   pOutDataBuf,
+   u16      bufferLen );
+
+// Check mandatory TLV in a QMI message
+int ValidQMIMessage(
+   void *   pQMIMessage,
+   u16      messageLen );
+
+// Get the message ID of a QMI message
+int GetQMIMessageID(
+   void *   pQMIMessage,
+   u16      messageLen );
+
+/*=========================================================================*/
+// Get sizes of buffers needed by QMI requests
+/*=========================================================================*/
+
+// Get size of buffer needed for QMUX
+u16 QMUXHeaderSize( void );
+
+// Get size of buffer needed for QMUX + QMICTLGetClientIDReq
+u16 QMICTLGetClientIDReqSize( void );
+
+// Get size of buffer needed for QMUX + QMICTLReleaseClientIDReq
+u16 QMICTLReleaseClientIDReqSize( void );
+
+// Get size of buffer needed for QMUX + QMICTLReadyReq
+u16 QMICTLReadyReqSize( void );
+
+// Get size of buffer needed for QMUX + QMIWDSSetEventReportReq
+u16 QMIWDSSetEventReportReqSize( void );
+
+// Get size of buffer needed for QMUX + QMIWDSGetPKGSRVCStatusReq
+u16 QMIWDSGetPKGSRVCStatusReqSize( void );
+
+// Get size of buffer needed for QMUX + QMIDMSGetMEIDReq
+u16 QMIDMSGetMEIDReqSize( void );
+
+// Get size of buffer needed for QMUX + QMIWDASetDataFormatReq
+u16 QMIWDASetDataFormatReqSize( void );
+
+// Get size of buffer needed for QMUX + QMICTLSyncReq
+u16 QMICTLSyncReqSize( void );
+
+/*=========================================================================*/
+// Fill Buffers with QMI requests
+/*=========================================================================*/
+
+// Fill buffer with QMI CTL Get Client ID Request
+int QMICTLGetClientIDReq(
+   void *   pBuffer,
+   u16      buffSize,
+   u8       transactionID,
+   u8       serviceType );
+
+// Fill buffer with QMI CTL Release Client ID Request
+int QMICTLReleaseClientIDReq(
+   void *   pBuffer,
+   u16      buffSize,
+   u8       transactionID,
+   u16      clientID );
+
+// Fill buffer with QMI CTL Get Version Info Request
+int QMICTLReadyReq(
+   void *   pBuffer,
+   u16      buffSize,
+   u8       transactionID );
+
+// Fill buffer with QMI WDS Set Event Report Request
+int QMIWDSSetEventReportReq(
+   void *   pBuffer,
+   u16      buffSize,
+   u16      transactionID );
+
+// Fill buffer with QMI WDS Get PKG SRVC Status Request
+int QMIWDSGetPKGSRVCStatusReq(
+   void *   pBuffer,
+   u16      buffSize,
+   u16      transactionID );
+
+// Fill buffer with QMI DMS Get Serial Numbers Request
+int QMIDMSGetMEIDReq(
+   void *   pBuffer,
+   u16      buffSize,
+   u16      transactionID );
+
+// Fill buffer with QMI WDA Set Data Format Request
+int QMIWDASetDataFormatReq(
+   void *   pBuffer,
+   u16      buffSize,
+   u16      transactionID );
+
+int QMICTLSyncReq(
+   void *   pBuffer,
+   u16      buffSize,
+   u16      transactionID );
+
+/*=========================================================================*/
+// Parse data from QMI responses
+/*=========================================================================*/
+
+// Parse the QMI CTL Get Client ID Resp
+int QMICTLGetClientIDResp(
+   void * pBuffer,
+   u16    buffSize,
+   u16 *  pClientID );
+
+// Verify the QMI CTL Release Client ID Resp is valid
+int QMICTLReleaseClientIDResp(
+   void *   pBuffer,
+   u16      buffSize );
+
+// Parse the QMI WDS Set Event Report Resp/Indication or
+//    QMI WDS Get PKG SRVC Status Resp/Indication
+int QMIWDSEventResp(
+   void *   pBuffer,
+   u16      buffSize,
+   u32 *    pTXOk,
+   u32 *    pRXOk,
+   u32 *    pTXErr,
+   u32 *    pRXErr,
+   u32 *    pTXOfl,
+   u32 *    pRXOfl,
+   u64 *    pTXBytesOk,
+   u64 *    pRXBytesOk,
+   bool *   pbLinkState,
+   bool *   pbReconfigure );
+
+// Parse the QMI DMS Get Serial Numbers Resp
+int QMIDMSGetMEIDResp(
+   void *   pBuffer,
+   u16      buffSize,
+   char *   pMEID,
+   int      meidSize );
+
+// Parse the QMI DMS Get Serial Numbers Resp
+int QMIWDASetDataFormatResp(
+   void *   pBuffer,
+   u16      buffSize );
+
+// Pasre the QMI CTL Sync Response
+int QMICTLSyncResp(
+   void *pBuffer,
+   u16  buffSize );
+
+// Get size of buffer needed for QMUX + QMIWDSBindMuxDataPortReq
+u16 QMIWDSBindMuxDataPortReqSize( void );
+
+// Fill buffer with QMI WDS Bind Mux Data Port Request
+int QMIWDSBindMuxDataPortReq(
+   u16      platid,
+   void *   pBuffer,
+   u16      buffSize,
+   u16      transactionID );
+
+// Parse the QMI WDS Bind Mux Data Port Resp
+int QMIWDSBindMuxDataPortResp(
+   void *   pBuffer,
+   u16      buffSize );
+
+// Get size of buffer needed for QMUX + QMIWDSBindMuxDataPortPreReq
+u16 QMIWDSBindMuxDataPortPreReqSize( void );
+
+// Fill buffer with QMI WDS Bind Mux Data Port Request
+int QMIWDSBindMuxDataPortPreReq(
+   void *   pBuffer,
+   u16      buffSize,
+   u16      transactionID,
+   unsigned int index );
diff -Naur a/drivers/net/usb/Structs.h b/drivers/net/usb/Structs.h
--- a/drivers/net/usb/Structs.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/net/usb/Structs.h	2020-01-15 10:24:16.058350591 +0800
@@ -0,0 +1,423 @@
+/*===========================================================================
+FILE:
+   Structs.h
+
+DESCRIPTION:
+   Declaration of structures used by the Qualcomm Linux USB Network driver
+   
+FUNCTIONS:
+   none
+
+Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of Code Aurora Forum nor
+      the names of its contributors may be used to endorse or promote
+      products derived from this software without specific prior written
+      permission.
+
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+===========================================================================*/
+
+//---------------------------------------------------------------------------
+// Pragmas
+//---------------------------------------------------------------------------
+#pragma once
+
+//---------------------------------------------------------------------------
+// Include Files
+//---------------------------------------------------------------------------
+#include <linux/etherdevice.h>
+#include <linux/ethtool.h>
+#include <linux/mii.h>
+#include <linux/usb.h>
+#include <linux/version.h>
+#include <linux/cdev.h>
+#include <linux/kthread.h>
+#include <linux/poll.h>
+#include <linux/completion.h>
+
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION( 2,6,22 ))
+#define bool      u8
+#define URB_FREE_BUFFER		0x0100	/* Free transfer buffer with the URB */
+
+/**
+ * usb_endpoint_type - get the endpoint's transfer type
+ * @epd: endpoint to be checked
+ *
+ * Returns one of USB_ENDPOINT_XFER_{CONTROL, ISOC, BULK, INT} according
+ * to @epd's transfer type.
+ */
+static inline int usb_endpoint_type(const struct usb_endpoint_descriptor *epd)
+{
+	return epd->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;
+}
+#endif
+
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION( 2,6,14 ))
+/**
+ * usb_endpoint_dir_in - check if the endpoint has IN direction
+ * @epd: endpoint to be checked
+ *
+ * Returns true if the endpoint is of type IN, otherwise it returns false.
+ */
+static inline int usb_endpoint_dir_in(const struct usb_endpoint_descriptor *epd)
+{
+	return ((epd->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == USB_DIR_IN);
+}
+
+/**
+ * usb_endpoint_dir_out - check if the endpoint has OUT direction
+ * @epd: endpoint to be checked
+ *
+ * Returns true if the endpoint is of type OUT, otherwise it returns false.
+ */
+static inline int usb_endpoint_dir_out(
+				const struct usb_endpoint_descriptor *epd)
+{
+	return ((epd->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == USB_DIR_OUT);
+}
+
+/**
+ * usb_endpoint_xfer_int - check if the endpoint has interrupt transfer type
+ * @epd: endpoint to be checked
+ *
+ * Returns true if the endpoint is of type interrupt, otherwise it returns
+ * false.
+ */
+static inline int usb_endpoint_xfer_int(
+				const struct usb_endpoint_descriptor *epd)
+{
+	return ((epd->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==
+		USB_ENDPOINT_XFER_INT);
+}
+
+static inline int usb_autopm_set_interface(struct usb_interface *intf)
+{ return 0; }
+
+static inline int usb_autopm_get_interface(struct usb_interface *intf)
+{ return 0; }
+
+static inline int usb_autopm_get_interface_async(struct usb_interface *intf)
+{ return 0; }
+
+static inline void usb_autopm_put_interface(struct usb_interface *intf)
+{ }
+static inline void usb_autopm_put_interface_async(struct usb_interface *intf)
+{ }
+static inline void usb_autopm_enable(struct usb_interface *intf)
+{ }
+static inline void usb_autopm_disable(struct usb_interface *intf)
+{ }
+static inline void usb_mark_last_busy(struct usb_device *udev)
+{ }
+#endif
+
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION( 2,6,24 ))
+   #include "usbnet.h"
+#else
+   #include <linux/usb/usbnet.h>
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION( 2,6,25 ))
+   #include <linux/fdtable.h>
+#else
+   #include <linux/file.h>
+#endif
+
+// Used in recursion, defined later below
+struct sGobiUSBNet;
+
+/*=========================================================================*/
+// Struct sReadMemList
+//
+//    Structure that defines an entry in a Read Memory linked list
+/*=========================================================================*/
+typedef struct sReadMemList
+{
+   /* Data buffer */
+   void *                     mpData;
+   
+   /* Transaction ID */
+   u16                        mTransactionID;
+
+   /* Size of data buffer */
+   u16                        mDataSize;
+
+   /* Next entry in linked list */
+   struct sReadMemList *      mpNext;
+
+} sReadMemList;
+
+/*=========================================================================*/
+// Struct sNotifyList
+//
+//    Structure that defines an entry in a Notification linked list
+/*=========================================================================*/
+typedef struct sNotifyList
+{
+   /* Function to be run when data becomes available */
+   void                  (* mpNotifyFunct)(struct sGobiUSBNet *, u16, void *);
+   
+   /* Transaction ID */
+   u16                   mTransactionID;
+
+   /* Data to provide as parameter to mpNotifyFunct */
+   void *                mpData;
+   
+   /* Next entry in linked list */
+   struct sNotifyList *  mpNext;
+
+} sNotifyList;
+
+/*=========================================================================*/
+// Struct sURBList
+//
+//    Structure that defines an entry in a URB linked list
+/*=========================================================================*/
+typedef struct sURBList
+{
+   /* The current URB */
+   struct urb *       mpURB;
+
+   /* Next entry in linked list */
+   struct sURBList *  mpNext;
+
+} sURBList;
+
+/*=========================================================================*/
+// Struct sClientMemList
+//
+//    Structure that defines an entry in a Client Memory linked list
+//      Stores data specific to a Service Type and Client ID
+/*=========================================================================*/
+typedef struct sClientMemList
+{
+   /* Client ID for this Client */
+   u16                          mClientID;
+
+   /* Linked list of Read entries */
+   /*    Stores data read from device before sending to client */
+   sReadMemList *               mpList;
+   
+   /* Linked list of Notification entries */
+   /*    Stores notification functions to be run as data becomes 
+         available or the device is removed */
+   sNotifyList *                mpReadNotifyList;
+
+   /* Linked list of URB entries */
+   /*    Stores pointers to outstanding URBs which need canceled 
+         when the client is deregistered or the device is removed */
+   sURBList *                   mpURBList;
+   
+   /* Next entry in linked list */
+   struct sClientMemList *      mpNext;
+
+   /* Wait queue object for poll() */
+   wait_queue_head_t    mWaitQueue;
+
+} sClientMemList;
+
+/*=========================================================================*/
+// Struct sURBSetupPacket
+//
+//    Structure that defines a USB Setup packet for Control URBs
+//    Taken from USB CDC specifications
+/*=========================================================================*/
+typedef struct sURBSetupPacket
+{
+   /* Request type */
+   u8    mRequestType;
+
+   /* Request code */
+   u8    mRequestCode;
+
+   /* Value */
+   u16   mValue;
+
+   /* Index */
+   u16   mIndex;
+
+   /* Length of Control URB */
+   u16   mLength;
+
+} sURBSetupPacket;
+
+// Common value for sURBSetupPacket.mLength
+#define DEFAULT_READ_URB_LENGTH 0x1000
+
+#ifdef CONFIG_PM
+#if (LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,29 ))
+/*=========================================================================*/
+// Struct sAutoPM
+//
+//    Structure used to manage AutoPM thread which determines whether the
+//    device is in use or may enter autosuspend.  Also submits net 
+//    transmissions asynchronously.
+/*=========================================================================*/
+typedef struct sAutoPM
+{
+   /* Thread for atomic autopm function */
+   struct task_struct *       mpThread;
+
+   /* Signal for completion when it's time for the thread to work */
+   struct completion          mThreadDoWork;
+
+   /* Time to exit? */
+   bool                       mbExit;
+
+   /* List of URB's queued to be sent to the device */
+   sURBList *                 mpURBList;
+
+   /* URB list lock (for adding and removing elements) */
+   spinlock_t                 mURBListLock;
+
+   /* Length of the URB list */
+   atomic_t                   mURBListLen;
+   
+   /* Active URB */
+   struct urb *               mpActiveURB;
+
+   /* Active URB lock (for adding and removing elements) */
+   spinlock_t                 mActiveURBLock;
+   
+   /* Duplicate pointer to USB device interface */
+   struct usb_interface *     mpIntf;
+
+} sAutoPM;
+#endif
+#endif /* CONFIG_PM */
+
+/*=========================================================================*/
+// Struct sQMIDev
+//
+//    Structure that defines the data for the QMI device
+/*=========================================================================*/
+typedef struct sQMIDev
+{
+   /* Device number */
+   dev_t                      mDevNum;
+
+   /* Device class */
+   struct class *             mpDevClass;
+
+   /* cdev struct */
+   struct cdev                mCdev;
+
+   /* is mCdev initialized? */
+   bool                       mbCdevIsInitialized;
+
+   /* Pointer to read URB */
+   struct urb *               mpReadURB;
+
+   /* Read setup packet */
+   sURBSetupPacket *          mpReadSetupPacket;
+
+   /* Read buffer attached to current read URB */
+   void *                     mpReadBuffer;
+   
+   /* Inturrupt URB */
+   /*    Used to asynchronously notify when read data is available */
+   struct urb *               mpIntURB;
+
+   /* Buffer used by Inturrupt URB */
+   void *                     mpIntBuffer;
+   
+   /* Pointer to memory linked list for all clients */
+   sClientMemList *           mpClientMemList;
+   
+   /* Spinlock for client Memory entries */
+   spinlock_t                 mClientMemLock;
+
+   /* Transaction ID associated with QMICTL "client" */
+   atomic_t                   mQMICTLTransactionID;
+
+} sQMIDev;
+
+/*=========================================================================*/
+// Struct sGobiUSBNet
+//
+//    Structure that defines the data associated with the Qualcomm USB device
+/*=========================================================================*/
+typedef struct sGobiUSBNet
+{
+    atomic_t refcount;
+
+   /* Net device structure */
+   struct usbnet *        mpNetDev;
+
+#if 1 //def DATA_MODE_RP
+   /* QMI "device" work in IP Mode or ETH Mode */
+   bool                   mbRawIPMode;
+#endif
+
+   struct completion mQMIReadyCompletion;
+   bool                   mbQMIReady;
+
+   /* Usb device interface */
+   struct usb_interface * mpIntf;
+
+   /* Pointers to usbnet_open and usbnet_stop functions */
+   int                  (* mpUSBNetOpen)(struct net_device *);
+   int                  (* mpUSBNetStop)(struct net_device *);
+   
+   /* Reason(s) why interface is down */
+   /* Used by Gobi*DownReason */
+   unsigned long          mDownReason;
+#define NO_NDIS_CONNECTION    0
+#define CDC_CONNECTION_SPEED  1
+#define DRIVER_SUSPENDED      2
+#define NET_IFACE_STOPPED     3
+
+   /* QMI "device" status */
+   bool                   mbQMIValid;
+
+   bool                   mbDeregisterQMIDevice;
+
+   /* QMI "device" memory */
+   sQMIDev                mQMIDev;
+
+   /* Device MEID */
+   char                   mMEID[14];
+   
+#ifdef CONFIG_PM
+   #if (LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,29 ))   
+   /* AutoPM thread */
+   sAutoPM                mAutoPM;
+#endif
+#endif /* CONFIG_PM */
+} sGobiUSBNet;
+
+/*=========================================================================*/
+// Struct sQMIFilpStorage
+//
+//    Structure that defines the storage each file handle contains
+//       Relates the file handle to a client
+/*=========================================================================*/
+typedef struct sQMIFilpStorage
+{
+   /* Client ID */
+   u16                  mClientID;
+   
+   /* Device pointer */
+   sGobiUSBNet *        mpDev;
+
+} sQMIFilpStorage;
+
diff -Naur a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c
--- a/drivers/usb/serial/option.c	2018-08-16 00:13:02.000000000 +0800
+++ b/drivers/usb/serial/option.c	2020-01-15 17:42:43.375178342 +0800
@@ -51,6 +51,7 @@
 static void option_instat_callback(struct urb *urb);
 
 /* Vendor and product IDs */
+#define FIBOCOM_VENDOR_ID 			0x2CB7      /*Nexsec add FIBOCOM vendor id */               
 #define OPTION_VENDOR_ID			0x0AF0
 #define OPTION_PRODUCT_COLT			0x5000
 #define OPTION_PRODUCT_RICOLA			0x6000
@@ -564,6 +565,12 @@
 
 
 static const struct usb_device_id option_ids[] = {
+	{ USB_DEVICE(FIBOCOM_VENDOR_ID, 0x0104) },     /*Nexsec add for FIBOCOM*/
+	{ USB_DEVICE(FIBOCOM_VENDOR_ID, 0x0105) },     /*Nexsec add for FIBOCOM*/
+	{ USB_DEVICE(FIBOCOM_VENDOR_ID, 0x0107) },     /*Nexsec add for FIBOCOM*/
+	{ USB_DEVICE(FIBOCOM_VENDOR_ID, 0x0108) },     /*Nexsec add for FIBOCOM*/
+	{ USB_DEVICE(FIBOCOM_VENDOR_ID, 0x0109) },     /*Nexsec add for FIBOCOM*/
+	{ USB_DEVICE(FIBOCOM_VENDOR_ID, 0x010a) },     /*Nexsec add for FIBOCOM*/
 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_COLT) },
 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_RICOLA) },
 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_RICOLA_LIGHT) },
@@ -2006,6 +2013,23 @@
 	    iface_desc->bInterfaceClass != USB_CLASS_CDC_DATA)
 		return -ENODEV;
 
+
+
+/*Nexsec add for FIBOCOM FG105*/
+if(serial->dev->descriptor.idVendor == FIBOCOM_VENDOR_ID &&
+(((serial->dev->descriptor.idProduct == cpu_to_le16(0x0104) ||
+serial->dev->descriptor.idProduct == cpu_to_le16(0x0105)) &&
+serial->interface->cur_altsetting->desc.bInterfaceNumber >= 4)||
+((serial->dev->descriptor.idProduct == cpu_to_le16(0x0109) ||
+serial->dev->descriptor.idProduct == cpu_to_le16(0x010A)) &&
+serial->interface->cur_altsetting->desc.bInterfaceNumber >= 2)))
+{
+printk(KERN_INFO "Discovery the interface for Fibocom .");
+return -ENODEV;
+}
+
+
+
 	/* Store the device flags so we can use them during attach. */
 	usb_set_serial_data(serial, (void *)device_flags);
 
